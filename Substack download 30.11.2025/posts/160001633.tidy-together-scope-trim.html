<p>The way I write books is I pick some tiny little scope, I say “there’s no way I can write a whole book about this”, then it turns out to be way too much, I get depressed &amp; stop writing, then eventually I decide “well which half of this is going into this book?”, I trim the scope, then I finish the suddenly within reach scope.</p><p>Two, maybe 3 rounds of cuts before I actually finish.</p><p>It’s time.</p><p>I could use some feedback from y’all. </p><ul><li><p>Would you find it valuable for me to finish the catalog of refactorings as outlined below? You’ve seen several example chapters. I find them tedious to write but valuable to use.</p></li><li><p>Are there topics below that you’d really like to see covered? Topics you can’t imagine caring about?</p></li></ul><h2>My Internal To-Do List</h2><p>Only some of the below will survive this round of cuts. Vote!</p><p><strong># TODO</strong></p><p>- Preface, including acknowledgements</p><p>- Symmetry</p><p>- Introduction</p><p>- We're back to steering--a little this way, a little that way, all while remaining aware of current road conditions, visible changes coming up. Critically, if we can predict the future &amp; guarantee we won't learn anything, then we can make a "good" (by this criterion) design up front. The more change &amp; the more learning, the less feasible one &amp; only "good" is. But also loss of NPV &amp; loss of optionality.</p><p>- Reducing visibility and/or scope reduces the chance of coupling. Not being able to reduce visibility or scope points to future design improvements.</p><p>- Principle--have state be as short-lived as possible &amp; as narrowly visible as possible. Or maybe this is a fitness function?</p><p>Refactorings</p><p>- Extract/inline function/method</p><p>- Extract/inline method object</p><p>- Move function/method</p><p>- Global to local state</p><p>- Move code up/down the call tree (field assignment, conditionals, ???)</p><p>- Static &lt;-&gt; instance</p><p>- Common parameter &lt;-&gt; constructor parameter + field</p><p>- Literal &lt;-&gt; Constant</p><p>- Increase/decrease visibility/scope</p><p>- Conditional in code to conditional in constructor or factory</p><p>- Constructor &lt;-&gt; Factory</p><p>- Flag field &lt;-&gt; subclasses</p><p>- Flag field &lt;-&gt; delegate</p><p>- Parameter &lt;-&gt; Field</p><p>- Index access &lt;-&gt; Named access</p><p>- Collection mutation &lt;-&gt; mutation methods</p><p>- Move Code To/From Data</p><p>- Function call &lt;-&gt; Event</p><p>- Allocate/Release &lt;-&gt; AllocateWhile</p><p>Management</p><p>- Authority &amp; Responsibility</p><p>- Trough of Despair</p><p>- Things always get worse before they get better</p><p>- Interface &amp; Implementation Hats</p><p>- Stop thinking. Which means think about the structure without recourse to the meaning of things. That's why the examples are pretty abstract, because it doesn't matter what things mean. If the design wants to go that way, help it go that way.</p><p>- Parallels (is there more to say?)</p><p>- Collective Ownership</p><p>- Pass Through Implementation</p><p>- Breaking Changes--tradeoff</p><p>- Timing--Pull vs. Push</p><p>- Make Change Easy</p><p>- Run/Right/Fast</p><p>- In-Process Money as a Metric</p><p>- Similar -&gt; Identical -&gt; De-Duplicate</p><p>- Effort/Output/Outcome/Impact (?)</p><p>- Testability</p><p>Theory</p><p>- Generating a Power Law (vs. Normal)</p><p>- Unreasonable Cost of Outliers</p><p>- Meaningless Mean</p><p>- Taxonomy of Couplings</p><p>- Emergent design. Encouraging the latent design to emerge as opposed to imposing ego. Talk about fostering emergence instead of imposing will. Differentiation vs assembly.</p><p>- Implicit Design Made Explicit</p><p>- Attractors</p><p>- Coupling &amp; Inheritance</p><p>- Symmetry</p><p>- Shape of Coupling/De-coupling Tradeoff</p><p>- Ethics</p>