<h2><strong>Pattern</strong></h2><p>You see the same set of fields in several objects.</p><h2><strong>Forward</strong></h2><p>Group the fields into a single object. Give the fields of the object the names (&amp; types, if applicable) of the fields. Replace the original fields with an instance of the fields object.</p><h2><strong>Example</strong></h2><p>Time intervals or periods are a common example. If you see classes like this:</p><p><code>Contract<br>  validFrom, validTo</code></p><p>Then you have a good candidate for a Fields Object. The symmetrical prefix is a blatant clue. Sometimes you have symmetrical clusters of fields:</p><p><code>Contract<br>  validFrom, validTo, proposedFrom, proposedTo</code></p><p>Even more blatant clue.</p><p>First, declare the field object:</p><p><code>Period<br>  from, to</code></p><p>Using the Parallels Technique, add a field to the contract:</p><p><code>Contract<br>  validFrom, validTo, valid</code></p><p>Everywhere you set the old fields, also set <code>from</code> or <code>to</code> in the <code>Period</code>.</p><p><code>Contract<br>  validFrom = ...<br>  valid.from = ...</code></p><p>(Yes, there's a conversation to be had about making <code>Period</code> immutable. Later.)</p><p>Now that we're guaranteed the validFrom == valid.from (this is where immutability comes in handy), we can replace references to the old field with references to the new sub-field:</p><p><code>Contract<br>  ...valid.from /* Used to be validFrom */</code></p><p>Now that there are no more references to the old fields, delete them:</p><p><code>Contract<br>  valid</code></p><h2><strong>Discussion</strong></h2><p>The Fields Object needs to be allocated somewhere. Two options:</p><p>- When the containing object is constructed</p><p>- When the fields are set</p><p><strong>[TODO what else goes here?]</strong></p><h2><strong>Coupling &amp; Cohesion</strong></h2><p>The Fields Object improves the cohesion of the containing object. The Field Object is also highly cohesive--if the from in our example needs to be changed, the to is also likely to be changed.</p><p>The Fields Object can reduce coupling. Instead of having to compute the intersection or union of time periods everywhere from &amp; to appear together, we have a natural single home for that code--the Period. No more worrying that you forgot to update one of the copies of that code.</p><p>The Fields Object can also become a useful hinge for variation. Say you want to compute time periods with from &amp; duration sometimes instead of from &amp; to. The Fields Object becomes a good place to capture that variation.</p><h2><strong>Inverse</strong></h2><p>Let's say you have a Fields Object but it's now only used in one place &amp; the object has no behavior. Inline it, just as you would with a lonely Parameters Object.</p><h2><strong>Subsequent refactorings</strong></h2><p>You may have an opportunity to Move Code To Data if you have expressions that only use data in the Fields Object.</p>