<div class="pullquote"><p>As a dog returns to his vomit, so a fool repeats his folly<br>— King James translation, Christian bible, Proverbs 26:11</p></div><p>I apologize for the icky metaphor, but I don’t have a better illustration of an effect I’m seeing. No illustration, so you’re welcome for that.</p><p>The problem, in general, is that it’s hard-to-impossible to get a genie to change its frame. I was discussing this problem with Data Wizard Josh Wills—you have some code structured one way &amp; you want the same behavior but a different structure. The genie will return, sometimes by twisty little passages, to the original structure, seemingly without regard to prompting.</p><h2>B+ Tree Insertion</h2><p>Today’s annoying example comes from my B+ Tree project, where I’m seeing if it is possible to generate library-quality code via augmented coding.</p><p>One of the key operations in any map data structure is insertion. The B+ tree keeps its keys &amp; data in fixed size nodes. Here’s how I think about insertion, assuming this is  new key.</p><p><code>index = self.find_index_for_insertion(key)<br>if self.has_space():<br>  return self.insert_at_index(index, key, value)<br>// we’re full, so split first<br>// the bigger half of the keys &amp; values go into the new node<br>new_right = self.split() // truncates my keys &amp; values<br>// now insert into the correct node<br>if index &lt; self.length():<br>  self.insert_at_index(index, key, value)<br>else:<br>  new_right.insert_at_index(index - self.length(), key, value)</code></p><p>Long story short—if we have space, just insert. If we are full, split, then insert.</p><p>So why, this very morning, did I have to change the code back, for at least the 4th time on this project, from a slightly different—still correct, but different—variant?</p><h2>Ancient History</h2><p>In July, 1970, one of the <a href="https://infolab.usc.edu/csci585/Spring2010/den_ar/indexing.pdf">first publications of the B+ tree appeared</a>. Called “ORGANIZATION AND MAINTENANCE OF LARGE ORDERED INDICES” by R. Bayer and E. McCreight, it described B trees &amp; my new favorite variant, B+ trees. “It is assumed that the index must be kept on some pseudo random access backup store like a disc or a drum.” Or RAM, in our case.</p><p>The B+ tree insertion logic is described like this:</p><div class="captioned-image-container"><figure><a class="image-link image2 is-viewable-img" target="_blank" href="https://substackcdn.com/image/fetch/$s_!UFoc!,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F3072bd5d-0a60-4295-b76e-0d614cb84358_1104x560.png" data-component-name="Image2ToDOM"><div class="image2-inset"><picture><source type="image/webp" srcset="https://substackcdn.com/image/fetch/$s_!UFoc!,w_424,c_limit,f_webp,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F3072bd5d-0a60-4295-b76e-0d614cb84358_1104x560.png 424w, https://substackcdn.com/image/fetch/$s_!UFoc!,w_848,c_limit,f_webp,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F3072bd5d-0a60-4295-b76e-0d614cb84358_1104x560.png 848w, https://substackcdn.com/image/fetch/$s_!UFoc!,w_1272,c_limit,f_webp,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F3072bd5d-0a60-4295-b76e-0d614cb84358_1104x560.png 1272w, https://substackcdn.com/image/fetch/$s_!UFoc!,w_1456,c_limit,f_webp,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F3072bd5d-0a60-4295-b76e-0d614cb84358_1104x560.png 1456w" sizes="100vw"><img src="https://substack-post-media.s3.amazonaws.com/public/images/3072bd5d-0a60-4295-b76e-0d614cb84358_1104x560.png" width="1104" height="560" data-attrs="{&quot;src&quot;:&quot;https://substack-post-media.s3.amazonaws.com/public/images/3072bd5d-0a60-4295-b76e-0d614cb84358_1104x560.png&quot;,&quot;srcNoWatermark&quot;:null,&quot;fullscreen&quot;:null,&quot;imageSize&quot;:null,&quot;height&quot;:560,&quot;width&quot;:1104,&quot;resizeWidth&quot;:null,&quot;bytes&quot;:91679,&quot;alt&quot;:&quot;Mathematical description of B-tree page splitting algorithm. Shows that when a full page P containing the sequence p₀, (x₁,p₁), (x₂,p₂), ..., (x₂ₖ₊₁,p₂ₖ₊₁) needs to be split, the first k entries p₀, (x₁,p₁), ..., (xₖ,pₖ) remain in page P, while a new page P' is created to contain the remaining entries pₖ₊₁, (xₖ₊₂,pₖ₊₂), (xₖ₊₃,pₖ₊₃), ..., (x₂ₖ₊₁,p₂ₖ₊₁).&quot;,&quot;title&quot;:null,&quot;type&quot;:&quot;image/png&quot;,&quot;href&quot;:null,&quot;belowTheFold&quot;:true,&quot;topImage&quot;:false,&quot;internalRedirect&quot;:&quot;https://tidyfirst.substack.com/i/171981761?img=https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F3072bd5d-0a60-4295-b76e-0d614cb84358_1104x560.png&quot;,&quot;isProcessing&quot;:false,&quot;align&quot;:null,&quot;offset&quot;:false}" class="sizing-normal" alt="Mathematical description of B-tree page splitting algorithm. Shows that when a full page P containing the sequence p₀, (x₁,p₁), (x₂,p₂), ..., (x₂ₖ₊₁,p₂ₖ₊₁) needs to be split, the first k entries p₀, (x₁,p₁), ..., (xₖ,pₖ) remain in page P, while a new page P' is created to contain the remaining entries pₖ₊₁, (xₖ₊₂,pₖ₊₂), (xₖ₊₃,pₖ₊₃), ..., (x₂ₖ₊₁,p₂ₖ₊₁)." title="Mathematical description of B-tree page splitting algorithm. Shows that when a full page P containing the sequence p₀, (x₁,p₁), (x₂,p₂), ..., (x₂ₖ₊₁,p₂ₖ₊₁) needs to be split, the first k entries p₀, (x₁,p₁), ..., (xₖ,pₖ) remain in page P, while a new page P' is created to contain the remaining entries pₖ₊₁, (xₖ₊₂,pₖ₊₂), (xₖ₊₃,pₖ₊₃), ..., (x₂ₖ₊₁,p₂ₖ₊₁)." srcset="https://substackcdn.com/image/fetch/$s_!UFoc!,w_424,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F3072bd5d-0a60-4295-b76e-0d614cb84358_1104x560.png 424w, https://substackcdn.com/image/fetch/$s_!UFoc!,w_848,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F3072bd5d-0a60-4295-b76e-0d614cb84358_1104x560.png 848w, https://substackcdn.com/image/fetch/$s_!UFoc!,w_1272,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F3072bd5d-0a60-4295-b76e-0d614cb84358_1104x560.png 1272w, https://substackcdn.com/image/fetch/$s_!UFoc!,w_1456,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F3072bd5d-0a60-4295-b76e-0d614cb84358_1104x560.png 1456w" sizes="100vw" loading="lazy"></picture><div class="image-link-expand"><div class="pencraft pc-display-flex pc-gap-8 pc-reset"><button tabindex="0" type="button" class="pencraft pc-reset pencraft icon-container restack-image"><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-refresh-cw"><path d="M3 12a9 9 0 0 1 9-9 9.75 9.75 0 0 1 6.74 2.74L21 8"></path><path d="M21 3v5h-5"></path><path d="M21 12a9 9 0 0 1-9 9 9.75 9.75 0 0 1-6.74-2.74L3 16"></path><path d="M8 16H3v5"></path></svg></button><button tabindex="0" type="button" class="pencraft pc-reset pencraft icon-container view-image"><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-maximize2 lucide-maximize-2"><polyline points="15 3 21 3 21 9"></polyline><polyline points="9 21 3 21 3 15"></polyline><line x1="21" x2="14" y1="3" y2="10"></line><line x1="3" x2="10" y1="21" y2="14"></line></svg></button></div></div></div></a></figure></div><p><em>First</em>, insert the new key. <em>Then</em>, if the node is over-full split it.</p><h2>Like A Dog</h2><p>This morning I had the third experience of looking at the insert code &amp; realizing that the genie had taken the code I’d explicitly written to split-then-insert &amp; rewritten it to insert-then-split. WTF!?!?</p><p>The genie is experiencing a kind of mean reversion, I think. It’s probably seen 1000 B+ tree implementations, all? most? conforming to the insert-then-split style. So it copies.</p><p>This is fine for when you want code that’s pretty much like other code. But what do you do when you want to innovate? I just inserted a comment, which the genie has mentioned a couple of times:</p><p><code>  // Don't insert first. That causes the Vecs to overflow.</code></p><p>Back to Josh Wills’ problem. No matter what he said, the genie always reverted to the previous structure. Seems like we’re all going to have to struggle with this until we get genies that are:</p><ul><li><p>Structure vs behavior aware.</p></li><li><p>Able to respect long-term goals like “structured like <em>this</em>”.</p></li></ul>