<blockquote><p>Finally, a Real Refactoring‚Ñ¢Ô∏è!  ü•≥ I‚Äôm really worried that what follows is too condensed for folks to follow, that readers will just give up. Please let me know what you think. As always, please pass along any real examples. Examples are the hardest part.</p></blockquote><h2>Pattern</h2><p>You see the same set of parameters passed through multiple levels of the call graph or you see them passed together in several different places in the code base.</p><h2>Forward</h2><p>Group the parameters into a single object. Give the fields of the object the names (&amp; types, if applicable) of the parameters.</p><p>Make the Parameters Object immutable. The last thing you want is some stupid aliasing error to change the behavior of the system behind your back.</p><h2>Example</h2><p>Pass x &amp; y separately or pass a Point?</p><p>   <code>foo(width, height) // invocation</code></p><p><code> function foo(x, y) ...</code></p><p>Using the Parallels Technique, we first add the new Parameters Object class:</p><p>   <code>class Point<br>   x, y</code></p><p>Then add a formal parameter &amp; null actual parameters:</p><p><code> foo(width, height, null)</code></p><p><code> function foo(x, y, p)</code></p><p>Now create &amp; pass the equivalent Point:</p><p><code> foo(width, height, new Point(width, height))</code></p><p>Now use the Point instead of x &amp; y:</p><p><code> function foo(x, y, p)<br>   // replace x with p.x</code></p><p>Now delete the now-unused parameter:</p><p><code> foo(height, new Point(width, height))</code></p><p><code> function foo(y, p)</code></p><p>(Note that this is a funky state for the code to be in. We probably wouldn't want to stop here, even though the code works just fine.)</p><p>Eliminate y the same way:</p><p><code> foo(width, new Point(width, height))</code></p><p><code> function foo(y, p)<br>   // replace y with p.y</code></p><p>And now that it's no longer used, delete y:</p><p><code> foo(new Point(width, height))</code></p><p><code> function foo(p)</code></p><h2>Discussion</h2><p>The Parameters object must be allocated at the top of the call graph. If this becomes a performance bottleneck, there's plenty of time to fix it later. Make it run, make it right, make it fast.</p><p>Do you introduce the Parameters Object from the top of the call graph to the bottom or bottom to top? I've done both, but my bias is towards top down. You create the Parameters Object in one place, then use it in more &amp; more places.</p><p>Parameters Objects also illustrate symmetry. The same cluster of parameters appears, symmetrically, in several parts of the code. By coalescing them into an object, we communicate that symmetry to readers.</p><p>What if you have parameter lists that are almost the same? I'd just hold off. Almost symmetrical means not symmetrical. There'll be time later if the lists become (or you make them) identical. It's fine to Reorder Parameters to make parameters lists or parts of parameter lists identical. [TODO: Reorder Parameters]</p><h2>Coupling &amp; Cohesion</h2><p>The Parameters Object makes parameter lists more cohesive. If we have code like:</p><p><code> foo(x, y, theta)</code></p><p>and we add a parameter to it, we'll be adding an element to a list of 3. If we instead add a parameter to:</p><p><code> foo(p, theta)</code></p><p>Then a larger percentage of the element changes. More cohesion.</p><p>Parameters Objects can also de-couple changes. No longer are all the functions coupled with respect to changes in the list of related parameters. Change the Parameters Object &amp; where it is allocated &amp; leave the rest of the functions alone.</p><p>Parameters Objects can also be a Hinge for change. By introducing an object protocol-compatible with the Parameters Object but with a different implementation, we may be able to easily change the behavior of the system without touching most of the code.</p><h2>Inverse</h2><p>Let's say you have a Parameters Object but it's now only used in one place, the object has no behavior, &amp; it's only passed once. Inline that sucker. Every element in the design carries a cost. If you had something in your backpack that you never used, you'd take it out, even if it's small &amp; light. No value, no carry. Same with designs.</p><h2>Subsequent Refactorings</h2><p>You may have an opportunity to Move Code To Data if you have expressions that only use data in the Parameters Object.</p>