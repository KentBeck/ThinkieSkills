<p>The <a href="https://medium.com/@kentbeck_7670/test-desiderata-94150638a4b3">Test Desiderata</a> collect desirable properties for tests. You can think of them as sliders—more of this, sometimes less of that. Alternatively, they form a 12-dimensional space of all possible tests.</p><p>I wrote the Test Desiderata when I noticed that some people fixate on a single kind of test, a single point in that space, and claim that those are the only valuable tests. We aren’t done exploring all of what testing can do for us as programmers or for those whose lives we affect with our programs.</p><p>Tim Ottinger <a href="https://twitter.com/tottinge/status/1483893575473631232">recently tweeted</a> about properties of unit tests, in particular the FIRST principles he compiled with Jeff Langr. They looked at good unit tests and described their properties. I realized I could just the opposite—look at the properties and use “settings” on each property to describe the attractor we call “unit tests”.</p><p>Here they are:</p><ul><li><p><a href="https://www.youtube.com/watch?v=HApI2cspQus">Isolated</a> — Unit tests are completely isolated from each other, creating their own test fixtures from scratch each time. (Note that I’m not saying these are the only useful tests, just that if tests aren’t isolated you’re going to have a hard time making the case that they are “unit tests”.)</p></li><li><p><a href="https://www.youtube.com/watch?v=Wf3WXYaMt8E">Composable</a> — Follows from isolation.</p></li><li><p><a href="https://www.youtube.com/watch?v=PwWyp-wpFiw">Deterministic</a> — Should be. Code that uses a clock or random numbers should be passed those values by their unit tests.</p></li><li><p><a href="https://www.youtube.com/watch?v=8lTfrCtPPNE">Specific</a> — If a unit test fails, the code of interest should be short.</p></li><li><p><a href="https://www.youtube.com/watch?v=5LOdKDqdWYU">Behavioral</a> — If the behavior changes accidentally, a unit test should fail.</p></li><li><p><a href="https://www.youtube.com/watch?v=bvRRbWbQwDU">Structure-insensitive</a> — This can be a challenge for unit tests. Too much mocking, especially strict mocking, is a structure sensitivity nightmare.</p></li><li><p><a href="https://www.youtube.com/watch?v=L0dZ7MmW6xc">Fast</a> — Yep.</p></li><li><p><a href="https://www.youtube.com/watch?v=CAttTEUE9HM">Writable</a> — Good interface design makes writing unit tests easier. Alternatively, difficult-to-write unit tests are the canary in the bad interface coal mine.</p></li><li><p><a href="https://www.youtube.com/watch?v=bDaFPACTjj8">Readable</a> — It can be challenge to write readable unit tests, because you are seeing so little context compared to the whole system.</p></li><li><p><a href="https://www.youtube.com/watch?v=YQlmP08dj6g">Automated</a> — Yep.</p></li><li><p><a href="https://www.youtube.com/watch?v=7o5qxxx7SmI">Predictive</a> — Unit tests passing likely gives little confidence that the whole system is working. Unit tests failing should give great confidence that the whole system is <strong>not</strong> working.</p></li><li><p><a href="https://www.youtube.com/watch?v=2Q1O8XBVbZQ">Inspiring</a> — A frequently-run unit test suite gives great confidence the programming is progressing. Sometimes I run my unit tests 2 or 3 times, just because it feels good (and they’re wicked fast).</p></li></ul>