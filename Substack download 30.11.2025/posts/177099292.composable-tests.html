<p>The Test Desiderata desires 12 properties for tests, two of which are:</p><ul><li><p>Isolation—the result of running one test should be completely independent of the results of other tests.</p></li><li><p>Composition—??? tests should run together ??? Isn’t that the same thing as isolation?</p></li></ul><p>No, and here’s why (I finally got an example—examples are always the hardest part.)</p><h2>Isolation</h2><p>If a test runs by first setting up its own test fixture, creating from scratch all the data it will be using as input, then that test is guaranteed to be <em>isolated</em>. It doesn’t matter what order you run the tests, the results will be exactly the same. (This is the same property as referential transparency in functional programming.)</p><p>Isolation is encouraged in the xUnit testing frameworks (at least most of them) by creating a new instance of a test object for every test &amp; running the setUp() function before running the test. (Some frameworks, notably NUnit, reuse test instances, opening the door to breaking isolation.)</p><h2>Composition</h2><p>Say we have a suite of isolated tests &amp; we run them all together. The suite’s success should give us confidence (be <em>predictive</em> in Desiderata terms), even though each individual test on its own isn’t comprehensive.</p><p>Example—say we have a test:</p><p><code>test1()<br>  object := new Whatever()<br>  actual := object.doSomething()<br>  assertEquals(expected, actual)</code></p><p>We get that working so we want to implement the next bit of functionality. We copy, paste, &amp; extend:</p><p><code>test2()<br>  object := new Whatever()<br>  actual := object.doSomething()<br>  assertEquals(expected, actual)<br>  actual2 := object.nowSomethingElse()<br>  assertEquals(expected2, actual2)</code></p><p>I have seen tests like this that have been copied, pasted, &amp; extended 6 or 7 times. That last test is pretty hard to read.</p><p>Notice that test2 can’t pass if test1 fails. All non-compliant programs caught by test1 will also be caught by test2. We have at least 3 options that preserve the same coverage, the same predictability:</p><ul><li><p>Leave both tests.</p></li><li><p>Delete test1.</p></li><li><p>Simplify test2.</p></li></ul><h2>Pruning</h2><p>From a purely aesthetic standpoint (&amp; don’t discount aesthetics), leaving both tests as is offends my sensibilities. They are redundant! Something <em>must</em> be wrong.</p><p>Deleting test1 loses us another property from the Test Desiderata—tests should be <em>specific</em>. That’s the property of tests where, when one fails, you know exactly where the problem is.</p><p>Which leads to my preferred solution—composition. I trim test2 to avoid the purely redundant parts:</p><p><code>test2()<br>  object := new Whatever()<br>  object.doSomething()<br>  actual := object.nowSomethingElse()<br>  assertEquals(expected, actual)</code></p><p>The composition of test1 + test2 hasn’t lost any of the predictive property. It hasn’t lost any of the specific property. In fact the composition may be more specific as it is possible for test1 to fail &amp; test2 to pass (although they may both fail for a common reason).</p><h2>N x M</h2><p>Let’s say we have 4 ways of computing interest &amp; 5 ways of reporting that interest. The brute force approach to testing this is 20 tests. Using composition, though, we can achieve the same confidence in our system with 10 tests. If the variants of computing interest are separated, in a functional programming sense, from the variants of reporting, then we need:</p><ul><li><p>4 tests for computation</p></li><li><p>5 tests for reporting</p></li><li><p>1 test that combines computing &amp; reporting, to demonstrate that they are wired together</p></li></ul><p>Gaining confidence from composed tests requires some thought, some inference, some design (to make the orthogonal dimensions demonstrably orthogonal), but the investment in writing pays off in making tests:</p><ul><li><p>Faster</p></li><li><p>More readable</p></li><li><p>Easier to change</p></li><li><p>More specific</p></li><li><p>Less sensitive to structure changes</p></li></ul><h2>Critique</h2><p>When I’ve explained what I mean by composable tests, I often receive shocked reactions from experienced testing-developers. “I would <em>never</em> reduce the assertions in a test.” This seems to me to be a reaction based in fear, not in principle. We worked <em>so hard</em> to get to write tests at all. We can’t make them <em>worse</em>.</p><p>Composition isn’t making tests worse. Composition is looking at the tests as a whole, trying to make the whole better as judged by several valuable properties of tests.</p><div><hr></div><p>Boost your team’s code quality and shipping speed with CodeRabbit—the most advanced AI code review tool built for engineers. CodeRabbit delivers context-aware, line-by-line reviews, instant one-click fixes, and concise PR summaries, integrating right into your GitHub workflow so you spend less time diff diving and more time building.​</p><h2>What Makes CodeRabbit Different?</h2><ul><li><p>CodeRabbit provides AI-powered reviews that adapt to your team’s standards, enforcing style, spotting bugs and edge cases, and mapping out code dependencies automatically.​</p></li><li><p>With multi-language support and over 40 linters and static analysis tools, it keeps your code clean, secure, and maintainable—no matter how complex your stack.​</p></li><li><p>Real examples show dramatic impact: SalesRabbit cut bugs by 30% and boosted engineering velocity by 25% simply by adding CodeRabbit to all deploys.​</p></li><li><p>Engineered to help junior and experienced devs alike, CodeRabbit catches issues even seasoned reviewers might miss, and its built-in documentation and reporting keep everyone informed and aligned.​</p></li></ul><h2>Try CodeRabbit Today</h2><p class="button-wrapper" data-attrs="{&quot;url&quot;:&quot;https://coderabbit.link/kent-beck&quot;,&quot;text&quot;:&quot;Try it Free for 14 Days&quot;,&quot;action&quot;:null,&quot;class&quot;:&quot;button-wrapper&quot;}" data-component-name="ButtonCreateButton"><a class="button primary button-wrapper" href="https://coderabbit.link/kent-beck"><span>Try it Free for 14 Days</span></a></p><blockquote><p>Join thousands of developers who’ve halved code review time and defect rates with CodeRabbit. Start your 14-day free trial and experience seamless AI reviews, actionable feedback, and effortless codebase learning.​</p><p>Ready to optimize your engineering workflow? (CodeRabbit is free for public repositories, with Pro features available for enterprise teams—start now to transform your code reviews)</p></blockquote><p><em>Sponsored by CodeRabbit.</em></p>