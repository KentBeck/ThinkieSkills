<p>Getting the genie to do good things to my code is often swamped by getting it <em>not</em> to do <em>bad</em> things.</p><p>I’m getting tired of telling the genie the same things over and over.</p><ul><li><p>Always commit all changed files.</p></li><li><p>Don’t write code without a failing test.</p></li><li><p>Only write the code necessary to get the test to pass.</p></li><li><p>Only commit when all tests are passing.</p></li><li><p>Never delete tests without express permission.</p></li><li><p>If you fake an implementation, put that in the commit message.</p></li></ul><p>And on and on. </p><p>My friend Jessica Kerr showed me a trick that I’ve been trying for a couple of days—persistent prompting. Have a file that contains the overall plan for the project &amp; any prompts you find yourself needing to repeat. Include a list of the tests that need to pass.</p><p>Tell the genie, “When I say ‘go’, read plan.md, take a test from the list, write it, see that it runs, make it pass, add any missing tests you discover to plan.md, mark the test as done, then commit &amp; push”.</p><p>It’s going a little better. Attached is the current plan.md for a B+ Tree data structure I’m implementing in Rust.</p><h2>The Current Plan</h2><p>We are implementing a BPlusTreeMap in Rust. We are writing the code like Kent Beck would write it. Before modifying code we consider whether tidying first would make the change easier. Commits will be separated into commits that change the behavior of the code and commits that only change the structure of the code. Write the code one test at a time. Write the test. Get it to compile. Get it to pass. Tidy after if appropriate.</p><p>By the time we are done we should have a plug replacement for BTreeMap. If during implementation you notice a test is needed that is not in the list, add it at the appropriate place in the list. As you complete tests, cross them off the list. Only implement enough code to make the test you just wrote pass, along with all the previous tests. If you find you have implemented too much, git revert --hard &amp; try again.</p><p>Each commit should have all the tests passing. Under no circumstances should you erase or alter tests just to get a commit to pass. If there is a genuine bug in a test, fix the test, but note that in the commit message.</p><p><strong>## Test Plan for BPlusTreeMap Implementation</strong></p><p><strong>### Basic Structure and Operations</strong></p><p>1. <s>~~Test creating an empty BPlusTreeMap~~</s> ✓</p><p>2. <s>~~Test inserting a single key-value pair~~</s> ✓</p><p>3. <s>~~Test retrieving a value by key~~</s> ✓</p><p>4. <s>~~Test overwriting an existing key's value~~</s> ✓</p><p>5. <s>~~Test removing a key-value pair~~</s> ✓</p><p>6. <s>~~Test checking if a key exists~~</s> ✓</p><p>7. <s>~~Test getting the number of elements (len)~~</s> ✓</p><p>8. Test checking if the map is empty</p><p><strong>### Core Collection Traits</strong></p><p>9. Test creating a BPlusTreeMap from an iterator (FromIterator)</p><p>10. Test extending a BPlusTreeMap with elements from an iterator (Extend)</p><p>11. Test converting a BPlusTreeMap into an iterator (IntoIterator)</p><p>12. Test Debug formatting</p><p>13. Test cloning a BPlusTreeMap (Clone)</p><p>14. Test creating an empty BPlusTreeMap with Default</p><p><strong>### Map-Specific Traits</strong></p><p>15. Test indexing syntax with Index&lt;K&gt;</p><p><strong>### Iterator Methods</strong></p><p>16. Test iterating over key-value pairs (iter)</p><p>17. Test iterating with mutable references (iter_mut)</p><p>18. Test consuming iteration (into_iter)</p><p>19. Test iterating over keys only (keys)</p><p>20. Test iterating over values only (values)</p><p>21. Test iterating over mutable values (values_mut)</p><p><strong>### Ordered Map Operations</strong></p><p>22. Test getting the first key-value pair</p><p>23. Test getting the last key-value pair</p><p>24. Test range iteration over a subset of keys</p><p>25. Test mutable range iteration</p><p>26. Test getting entries for manipulation</p><p><strong>### Advanced Operations</strong></p><p>27. Test appending one map to another</p><p>28. Test clearing all elements</p><p>29. Test retaining elements based on a predicate</p><p>30. Test entry API for conditional insertion/modification</p><p><strong>### Edge Cases</strong></p><p>31. Test behavior with very large number of elements</p><p>32. Test with complex key types that implement Ord</p><p>33. Test proper memory management (no leaks)</p><p>34. Test with keys at the boundaries of their range (min/max integers)</p><p>35. Test with keys that have the same hash but are different (hash collision)</p><p>36. Test with empty strings as keys or values</p><p>37. Test with very long keys or values (e.g., large strings)</p><p>38. Test with non-ASCII characters in keys or values</p><p>39. Test with unbalanced trees (many insertions/deletions on one side)</p><p>40. Test with repeated insertions and deletions in the same location</p><p>41. Test with operations that cause multiple node splits or merges</p><p>42. Test with operations that cause root node changes</p><p>43. Test with operations near the branching factor boundary</p><p>44. Test with custom comparators for key ordering</p><p>45. Test with reverse ordering of keys</p><p>46. Test with concurrent access from multiple threads</p><p>47. Test with thread safety and synchronization</p><p>48. Test with serialization and deserialization of the tree</p><p>49. Test with persistence across program restarts</p><p>50. Test with error handling during operations</p><p>51. Test with zero-sized types as keys or values</p><p>52. Test with self-referential structures as values</p><p>53. Test with floating-point numbers as keys (precision issues)</p><p>54. Test with very similar keys that test comparison precision</p><p>55. Test with random access patterns vs sequential access patterns</p><p>56. Test with extremely uneven distribution of keys</p><p>57. Test with pathological insertion orders that cause worst-case behavior</p><p>58. Test with keys that trigger edge cases in the comparison function</p><p>59. Test with operations that hit every code path in node splitting/merging</p><p>60. Test with operations during iteration (modification during traversal)</p>