<blockquote><p>I swear I never intended to publish a bunch more on TDD. But here we are. This is one from the archives, first published November 2010. It’s for TDDers who want to stretch their skills. In Tidy First? land we talk about the Succession Problem—in what order do we make decisions? The more, different orders you can manage, the more options you have for:</p><ul><li><p>Realizing value sooner</p></li><li><p>Deferring investment without dramatically increasing cost</p></li><li><p>Side-stepping “blockers”</p></li></ul><p>What follows is an exercise intended to stretch your ability to take decisions in many different sequences.</p></blockquote><p>As part of a recent advanced TDD course, we took a careful look at a simple stack implementation TDD-style. Here are the decisions that went into designing and implementing the stack. First, the specification decisions:</p><ul><li><p>Stack is an object</p></li><li><p>Name is “Stack”</p></li><li><p>There is an operation to add an element</p></li><li><p>It is called “push”</p></li><li><p>It takes a parameter</p></li><li><p>The type of the parameter is the same as the type of the stack</p></li><li><p>Stack has a type parameter</p></li><li><p>There is an operation to remove elements</p></li><li><p>Its name is “pop”</p></li><li><p>Its return value is the same as the type of the stack</p></li><li><p>Elements are ordered LIFO</p></li></ul><p>Here are the implementation decisions:</p><ul><li><p>Store the elements in a List</p></li><li><p>Type of the list is the same as the type of the stack</p></li><li><p>Implementation type is ArrayList</p></li><li><p>Add/remove elements at the beginning of the list</p></li></ul><p>Here’s the exercise: start with any decision above &amp; TDD, then another, and another. Pay attention to how frequently you can reach a green test. Pay attention to which sequences of decisions actually make sense.</p><p>What we found was that of the 15! [ed: 1,307,674,368,000] permutations of decisions, many of them worked just fine and could be used for different purposes.</p><blockquote><p>One of the fun variants I remember is putting off making an object as long as possible. The first few test cases had snippets of code for push &amp; pop just inline. This is the kind of sequence that most folks would never consider, but that can be valuable when e.g. you want to explore an algorithm without committing (even temporarily) to an API.</p></blockquote>