<p>There’s no way, augmented or not, for me to follow up on all the ideas I’m generating as I explore augmented coding. Here’s one for free that I may or may not try myself. I really really really want it to work, though, and I’ll pay to use it if you make good progress.</p><p>Here’s the premise: LLMs are trained on snapshots of code (as I understand the current practice—please correct me if I’m wrong). They look at a large code base at a point in time &amp; see, for example, lots of stuff that’s there for “backwards compatibility”. So they generate or retain a lot of code for “backwards compatibility” whether or not there is a backwards to be compatible with.</p><p>This applies to more complex design patterns as well. I’ve had genies insert factories &amp; registries &amp; interfaces where they served absolutely no purpose but to obscure the structure of the code. I assume the model saw lots of code bases that used these patterns &amp; decided they were good. And maybe they <em>were</em> good in the code the genie trained on, but not on my little projects, not yet anyway.</p><blockquote><p>For the next month I’m making it easier for aspiring augmented coders to join our community.</p></blockquote><p class="button-wrapper" data-attrs="{&quot;url&quot;:&quot;https://tidyfirst.substack.com/subscribe?coupon=6a55a5f6&amp;utm_content=163976503&quot;,&quot;text&quot;:&quot;Get 40% off for 1 year&quot;,&quot;action&quot;:null,&quot;class&quot;:null}" data-component-name="ButtonCreateButton"><a class="button primary" href="https://tidyfirst.substack.com/subscribe?coupon=6a55a5f6&amp;utm_content=163976503"><span>Get 40% off for 1 year</span></a></p><h2>Ch-ch-ch-ch-changes</h2><p>The first problem with training on big snapshots of code bases is this bias towards big-codebase techniques. There’s nothing in the training, that I can see anyway, about <em>when</em> the technique crossed from “annoying complexity” to “essential simplification”. Nothing about <em>why</em>.</p><p>The second problem of training on big snapshots of code bases is that the genie becomes overconfident (yes, I know I’m anthropomorphizing here but heck I’m pairing with a machine at 32,000 feet so I’m cutting myself some slack). The genie has a system, sees a prompt, &amp; wants to make changes until it gets to the new system.</p><div class="captioned-image-container"><figure><a class="image-link image2 is-viewable-img" target="_blank" href="https://substackcdn.com/image/fetch/$s_!Na87!,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Ff1bd515d-87de-4d6b-b43f-bac5b4ab1f8f_1562x933.jpeg" data-component-name="Image2ToDOM"><div class="image2-inset"><picture><source type="image/webp" srcset="https://substackcdn.com/image/fetch/$s_!Na87!,w_424,c_limit,f_webp,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Ff1bd515d-87de-4d6b-b43f-bac5b4ab1f8f_1562x933.jpeg 424w, https://substackcdn.com/image/fetch/$s_!Na87!,w_848,c_limit,f_webp,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Ff1bd515d-87de-4d6b-b43f-bac5b4ab1f8f_1562x933.jpeg 848w, https://substackcdn.com/image/fetch/$s_!Na87!,w_1272,c_limit,f_webp,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Ff1bd515d-87de-4d6b-b43f-bac5b4ab1f8f_1562x933.jpeg 1272w, https://substackcdn.com/image/fetch/$s_!Na87!,w_1456,c_limit,f_webp,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Ff1bd515d-87de-4d6b-b43f-bac5b4ab1f8f_1562x933.jpeg 1456w" sizes="100vw"><img src="https://substack-post-media.s3.amazonaws.com/public/images/f1bd515d-87de-4d6b-b43f-bac5b4ab1f8f_1562x933.jpeg" width="1456" height="870" data-attrs="{&quot;src&quot;:&quot;https://substack-post-media.s3.amazonaws.com/public/images/f1bd515d-87de-4d6b-b43f-bac5b4ab1f8f_1562x933.jpeg&quot;,&quot;srcNoWatermark&quot;:null,&quot;fullscreen&quot;:null,&quot;imageSize&quot;:null,&quot;height&quot;:870,&quot;width&quot;:1456,&quot;resizeWidth&quot;:null,&quot;bytes&quot;:430821,&quot;alt&quot;:&quot;The current system is atop a small hill. A prompt leads to a new and better system atop a higher hill. Between them is the swamp of complexity.&quot;,&quot;title&quot;:null,&quot;type&quot;:&quot;image/jpeg&quot;,&quot;href&quot;:null,&quot;belowTheFold&quot;:false,&quot;topImage&quot;:true,&quot;internalRedirect&quot;:&quot;https://tidyfirst.substack.com/i/163976503?img=https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Ff1bd515d-87de-4d6b-b43f-bac5b4ab1f8f_1562x933.jpeg&quot;,&quot;isProcessing&quot;:false,&quot;align&quot;:null,&quot;offset&quot;:false}" class="sizing-normal" alt="The current system is atop a small hill. A prompt leads to a new and better system atop a higher hill. Between them is the swamp of complexity." title="The current system is atop a small hill. A prompt leads to a new and better system atop a higher hill. Between them is the swamp of complexity." srcset="https://substackcdn.com/image/fetch/$s_!Na87!,w_424,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Ff1bd515d-87de-4d6b-b43f-bac5b4ab1f8f_1562x933.jpeg 424w, https://substackcdn.com/image/fetch/$s_!Na87!,w_848,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Ff1bd515d-87de-4d6b-b43f-bac5b4ab1f8f_1562x933.jpeg 848w, https://substackcdn.com/image/fetch/$s_!Na87!,w_1272,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Ff1bd515d-87de-4d6b-b43f-bac5b4ab1f8f_1562x933.jpeg 1272w, https://substackcdn.com/image/fetch/$s_!Na87!,w_1456,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Ff1bd515d-87de-4d6b-b43f-bac5b4ab1f8f_1562x933.jpeg 1456w" sizes="100vw" fetchpriority="high"></picture><div class="image-link-expand"><div class="pencraft pc-display-flex pc-gap-8 pc-reset"><button tabindex="0" type="button" class="pencraft pc-reset pencraft icon-container restack-image"><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-refresh-cw"><path d="M3 12a9 9 0 0 1 9-9 9.75 9.75 0 0 1 6.74 2.74L21 8"></path><path d="M21 3v5h-5"></path><path d="M21 12a9 9 0 0 1-9 9 9.75 9.75 0 0 1-6.74-2.74L3 16"></path><path d="M8 16H3v5"></path></svg></button><button tabindex="0" type="button" class="pencraft pc-reset pencraft icon-container view-image"><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-maximize2 lucide-maximize-2"><polyline points="15 3 21 3 21 9"></polyline><polyline points="9 21 3 21 3 15"></polyline><line x1="21" x2="14" y1="3" y2="10"></line><line x1="3" x2="10" y1="21" y2="14"></line></svg></button></div></div></div></a></figure></div><p>The bigger &amp; more complex the system, the greater the chance that the genie will get stuck in the swamp of complexity. It simply can’t get there from here, not with the current size of context windows &amp; the current level of genie planning &amp; execution.</p><h2>Small, Safe Steps</h2><p>Now maybe this is just me being an old fuddy duddy, but:</p><ul><li><p>I have a host of techniques during programming so things don’t get much worse before they get better &amp;</p></li><li><p>I’d like my genie to use those techniques.</p></li></ul><p>I’m talking about techniques like programmer testing, test first, parallels, tidy first, “make the change easy”, fast tests, separating behavior &amp; structure changes, separating interface &amp; implementation changes.</p><p>I can get genies doing a little bit of this stuff sometimes using system prompts. But the genie is astonishingly bad at safe sequencing &amp; willing to abandon it at the first signs of resistance. This is a pity, too, because the genie has the potential to be really good at small, safe steps. As a human I sometimes get side-tracked in the middle of a sequence. My genie wouldn’t.</p><h2>Training?</h2><p>Say we start with a tiny little system. Then we introduce a change that makes it a little bigger. Then another. As my friend Keith Adams put it, “There’s much more information in the right triangle of accumulating changes than there is in the final result at the base of the triangle.”</p><p>The following is complete speculation on my part. I’ve never trained a large model. But these are what I would try.</p><p>The first level of training is to find code bases that have evolved through lots of small, safe changes &amp; train the model on the diffs as well as the code.</p><p>The next level is noting that even small, safe diffs are composed (or can/should be composed) of even smaller, safer changes—individual refactorings strung together, individual behavior changes backed by tests. I want my genie to understand &amp; plan for code changes at this level of detail, not “oh I edit this file then I edit that file”. I’m not sure how to train for this. Maybe generate &amp; test &amp; note which sequences of changes are likely to lead to better programs,</p><p>The last level that makes sense to me is to run all changes as syntax tree transforms instead of text. I’ve been absolutely astonished how well LLMs do using tokens to predict code, but I don’t see how they’ll ever get really good at making changes without knowing about the structure of code.</p><p>As I said, all of the above could be wildly wrong, overtaken by evolution of general genies, or just plain ineffective. But I can dream.</p><h2>Generate &amp; Test</h2><p>Another approach is to use refactorings + the transformation priority premise<a class="footnote-anchor" data-component-name="FootnoteAnchorToDOM" id="footnote-anchor-1" href="#footnote-1" target="_self">1</a> to generate a host of successor programs, then only hang on to the promising ones. After a while of doing this, the genie could learn which structure &amp; behavior changes are most likely to result in a “fit” successor.</p><h2>Justified Confidence</h2><p>However the next generation of genies is structured or trained, the result I’m looking for is an augmentation that works better—fewer dead ends, less useless code, fewer defects, quicker, cheaper. Perhaps it’s not surprising that I see genies in horseless carriage terms. I just want a genie that codes like I do at my best. And then I want them to be better.</p><div class="footnote" data-component-name="FootnoteToDOM"><a id="footnote-1" href="#footnote-anchor-1" class="footnote-number" contenteditable="false" target="_self">1</a><div class="footnote-content"><p>The transformation priority premise is to behavior changes what refactorings are to structure changes. When a test fails, use the lowest-numbered transformation to get it passing. Robert Martin <a href="https://blog.cleancoder.com/uncle-bob/2013/05/27/TheTransformationPriorityPremise.html">listed them</a> as:</p><ol><li><p><strong>({} → nil):</strong> No code at all → Code that returns or employs <code>nil</code></p></li><li><p><strong>(nil → constant):</strong> Replace <code>nil</code> with a constant value</p></li><li><p><strong>(constant → constant+):</strong> Replace a simple constant with a more complex constant</p></li><li><p><strong>(constant → scalar):</strong> Replace a constant with a variable or argument</p></li><li><p><strong>(statement → statements):</strong> Add more unconditional statements</p></li><li><p><strong>(unconditional → if):</strong> Introduce a conditional (split the execution path)</p></li><li><p><strong>(scalar → array):</strong> Replace a scalar with an array</p></li><li><p><strong>(array → container):</strong> Replace an array with a more complex container (e.g., list, map)</p></li><li><p><strong>(statement → tail-recursion):</strong> Replace a statement with a tail-recursive structure</p></li><li><p><strong>(if → while):</strong> Replace a conditional with a loop</p></li><li><p><strong>(statement → non-tail-recursion):</strong> Replace a statement with a non-tail-recursive structure</p></li><li><p><strong>(expression → function):</strong> Replace an expression with a function or algorithm</p></li><li><p><strong>(variable → assignment):</strong> Replace the value of a variable (introduce assignment)</p></li><li><p><strong>(case):</strong> Add a case (or else) to an existing switch or if statement</p></li></ol><p></p></div></div>