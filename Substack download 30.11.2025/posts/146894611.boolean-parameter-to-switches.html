<blockquote><p>I think this is the first refactoring I’ve drafted that focuses on API evolution. I’m curious to see how many more I collect. Feel free to let me know about your favorites. I’m also wondering how useful this distinction will be.</p></blockquote><h3>Pattern</h3><p>You see an API function that takes a single boolean parameter.</p><h3>Forward</h3><p>Replace the API function with 2 functions, one representing the parameter being true &amp; one for false. Additionally, consider adding a function that switches the state.</p><h3>Example</h3><p>Suppose you see an API function:</p><pre><code>setOpen(boolean state)</code></pre><p>First we declare 2 new functions:</p><pre><code>open()
    this.setOpen(true)</code></pre><pre><code>close()
    this.setOpen(false)</code></pre><p>Now go to the callers &amp; replace <code>setOpen(true)</code> with <code>open()</code> &amp; <code>setOpen(false)</code> with <code>close()</code>. (If this replacement doesn’t clarify the calling code then don’t use this refactoring!)</p><p>If you see code that toggles the state of being open:</p><pre><code>if (foo.getOpen())
    foo.setOpen(false)
else
    foo.setOpen(true)</code></pre><p>Then Move Code To State &amp; add an API function to do the toggling for clients:</p><pre><code>toggle()
    if (this.isOpen())
        close()
    else
        open()</code></pre><h3>Discussion</h3><p>Good API design makes the calling code more readable. Each call conveys intention—​here’s what I want to have happen. The boolean parameter can conceal intention (with the exceptions listed below). Okay, you want to change the state, but what do you want to change the state <em>to</em>?</p><p>The switch functions tell readers what state change is desired. The toggle function tells readers, "I don’t care about the current state, I just want it to change."</p><p>This pattern contradicts the general principle that APIs should be as narrow as possible. The single boolean parameter was an over-compression of the API. Yes, we can represent the same API with fewer functions but we lose valuable information in the process.</p><h3>Coupling &amp; Cohesion</h3><p>Switch functions come in handy if you ever move from 2 states to 3 or more. Old code can keep using the same (subset of the) API while new code uses the new states. The alternative is to replace all those booleans in all the callers with an enum. The representation of the API was coupled to the number of states.</p><h3>Inverse</h3><p>The goal of taking a single API function with a boolean parameter &amp; replacing it with 2 or 3 API functions is to make callers more readable. If callers become harder to read with the switch functions, if every caller looks like this:</p><pre><code>shouldBeOpen = ... // doesn't involve foo
if (shouldBeOpen)
    foo.open()
else
    foo.close()</code></pre><p>Then:</p><ol><li><p>Make setOpen(boolean) part of the API again.</p></li><li><p>Inline all those callers of <code>open()</code> &amp; <code>close()</code>.</p></li><li><p>Delete <code>open()</code> &amp; <code>close()</code>.</p></li></ol><h3>Subsequent refactorings</h3><p>The object with the switch functions may now be ready to simplify.</p>