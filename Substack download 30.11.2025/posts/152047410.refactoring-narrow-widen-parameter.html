<blockquote><p>I decided to just plow through the whole catalog of refactorings. They are all useful, but they aren’t so exciting to write. Boo hoo. I need to get them done, &amp; not writing them will never get them done.</p><p>I’d love feedback on this one. Implementing the refactoring is a little tricky (but fun, for me anyway). Do you get it? How about the discussion of aggregates? (I would just say “object” and be done with it, but I want to include our functional siblings.)</p></blockquote><p>Sometimes you pass a whole aggregate as a parameter but really you only need one bit of it. The reverse is also true. Maybe you started out passing one field of the aggregate to a function. Then another. Then another. At some point, you may as well pass the whole aggregate.</p><p>The example I’ve seen repeatedly is large domain objects being passed all over the place. Contract, User, Product—things like that. If you only use one number out of the object in a function, you still have to spend time &amp; effort creating a valid User to write a test. Constructing a big object like a User can be computationally or conceptually expensive.</p><h2>Pattern</h2><p>Look for a large aggregate passed to a function that only uses a tiny part of the aggregate.</p><h2>Forward</h2><p>Executing this refactoring is kind of a fun trick.</p><p><code>caller():<br>  called(user)</code></p><p><code>called(user):<br>  ...code that uses user.age...</code></p><p>First extract a temporary variable for the part of the aggregate actually used.</p><p><code>called(user):<br>  age = user.age<br>  ...code now uses age...</code></p><p>Now extract the body of the called function.</p><p><code>called(user):<br>  age = user.age<br>  called_new(age)</code></p><p><code>called_new(age):<br>  ...code now uses age...</code></p><p>Inline the called function in all callers &amp; delete it.</p><p><code>caller():<br>  called_new(user.age)</code></p><p><code>called_new(age):<br>  ...cade uses age...</code></p><p>And rename called_new():</p><p><code>caller():<br>  called(user.age)</code></p><p><code>called(age):<br>  ...cade uses age...</code></p><h2>Discussion</h2><p>There’s something simple &amp; satisfying about passing a big-ol-object. What are we going to need from a User? Who cares? It’s all there. Passing those big objects around, though, makes it hard to analyze where parts of the object are used. Anything could be used anywhere.</p><p>The inverse case, where we are deconstructing most or all of an aggregate, tends to creep up on you. We need this bit. Good. We’ll just pass that bit. Oh and that bit too. Okay. And that one. And that one.</p><p>Reading such code it’s hard to grasp that entirety of the aggregate is used. Better to express the reality directly. Just pass the whole thing because we use the whole thing.</p><h2>Coupling &amp; Cohesion</h2><p>The forward case, where we pass too much, exposes the called code to changes in the aggregate passed. If code all over the system assumes a certain structure for User, changing that structure is going to trigger all kinds of coupled changes.</p><p>The inverse case also creates coupling. If we add a field to the aggregate &amp; we’re passing all the fields separately, then we have to change all the functions to add the field. Better to just add the field to the aggregate, then decide where in the code we need the new field.</p><h2>Inverse</h2><p>Use a parallel to introduce the aggregate.</p><p><code>caller():  <br>  called(point.x, point.y)</code></p><p><code>called(x, y):<br>  ...code that uses x &amp; y...</code></p><p>Becomes:</p><p><code>caller(): <br>  called(point.x, point.y, point)</code></p><p><code>called(x, y, point):<br>  ...code that uses x &amp; y...</code></p><p>Replace uses of x &amp; y:</p><p><code>called(x, y, point):<br>  ...code that uses point.x &amp; point.y...</code></p><p>Now the parameters aren’t used, so delete them:</p><p><code>caller():<br>  called(point)</code></p><p><code>called(point):<br>  ...code that uses point.x &amp; point.y...</code></p><h2>Subsequent refactorings</h2><p>[TODO]</p>