<p>What is software design? I'm not a fan of starting with definitions, but we're hardly starting by now. You've seen examples of what I mean by design. You've seen how individual decisions chain together to achieve larger goals. You've seen the first glimpses of what I mean by "software design is an exercise in human relationships". Now I can say what I mean by "software design":</p><blockquote><p>Beneficially relating elements</p></blockquote><p>That's not many words for a big concept. Each word must be carrying substantial weight. Let's pick them apart &amp; then put them back together.</p><div class="paywall-jump" data-component-name="PaywallToDOM"></div><h2><strong>Elements</strong></h2><p>Substantial structures have parts. Organelle&gt;&gt;organ&gt;&gt;organism. Atoms&gt;&gt;molecules&gt;&gt;crystals. In our world, tokens&gt;&gt;expressions&gt;&gt;statements&gt;&gt;functions&gt;&gt;objects/modules&gt;&gt;systems.<br>Elements have boundaries. You know where they start &amp; end.</p><p>Elements contain sub-elements. In our world we like to have homogenous hierarchies (<em>_a la_</em> the Composite pattern). Natural hierarchies, like the examples above, are not homogenous. Contained sub-elements differ from the container. (I'm not sure this point is terribly important, but I like to keep it in mind--some day I'll write a truly philosophical book about software design as a natural process.)</p><h2><strong>Relating</strong></h2><p>Okay, so we have a hierarchy of elements. Those elements exist in relation to each other. One function calls another. The functions are the elements. "Calls/called by" is the relationship. In the natural world we have relationships like "eats", "shades", and "fertilizes".</p><p>In software design we have a handful of relationships:</p><ul><li><p>Invokes</p></li><li><p>Publishes</p></li><li><p>Listens</p></li><li><p>Refers (as in fetching the value of a variable)</p></li></ul><p>[Hmmm, this is an awfully short list. Must take a shot at a comprehensive list.]</p><h2><strong>Beneficially</strong></h2><p>Here's where the magic happens. One design is to have a single gigantic soup of tiny sub-elements. Think assembly language with a global namespace. This program would work. It would behave for an external observer exactly the same as a well-designed program. Quickly, however, we couldn't change it. There are too many relationships, often implicit, between the elements.</p><p>By designing, by creating intermediate elements between the machine instructions &amp; the whole, those intermediate elements begin benefitting each other. "This function can be simpler because that other function takes care of the complexity of a part of the calculation."</p><p>[Is there a catalog of benefits like the catalog of relationships? Maybe that goes in the next book.]</p><h2><strong>Beneficially Relating Elements</strong></h2><p>One reading of the phrase "beneficially relating elements" starts with "the design is...". What is the design? It's the elements, their relationships, &amp; the benefits derived from those relationships.</p><p>Another reading starts with "designers are...". What do designers do? They beneficially relate elements. From this perspective, software designers can only:</p><ul><li><p>Create &amp; delete elements</p></li><li><p>Create &amp; delete relationships</p></li><li><p>Increase the benefit of a relationship</p></li></ul><p>There, easy, right? (&lt;- sarcasm warning).</p><p>Take one of my favorite examples: I have an object that invokes another object twice in one function:</p><pre><code>caller()
    return box.width() * box.height()</code></pre><p>The calling function has 2 relationships with the box, that of invoking 2 functions.</p><p>Move the expression into the box:</p><pre><code>caller()
    return box.area()

Box.area()
    return width() * height()</code></pre><p>From a design standpoint we have created a new element &amp; adjusted the relationship between the existing elements. Now they are related by a single function invocation, with the benefit that the calling function is simpler &amp; the cost that the Box is one function larger. (I'm guessing we'll return to this technique in greater depth in the following book.)</p><p>When I talk about the structure of the system, I'm talking about:</p><ul><li><p>The element hierarchy</p></li><li><p>The relationships between elements</p></li><li><p>The benefits created by those relationships</p></li></ul><p>Now we can make a firmer distinction between the structure &amp; the behavior of the system.</p>