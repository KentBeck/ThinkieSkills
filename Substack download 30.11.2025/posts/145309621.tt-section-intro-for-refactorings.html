<blockquote><p>After reading this intro you should be prepared to read a catalog of refactorings roughly on the scale of Fowler’s book. What needs to be added to this intro to make that more likely? What’s missing for you? What can be deferred?</p></blockquote><p>As with <em>Tidy First?</em> we begin this book with things you can do to change the structure of your code. I work from specific to general so that's how I'll write (jump to section 2 if you want to manage your current design changes better or section 3 if you want to start with theory).</p><p>Empirical Software Design occurs as the composition or sequencing of small design changes. The motto is "large changes in small, safe steps". What follows is a catalog of those steps at the scale of code that spans multiple people on a team.</p><p>In <em>Tidy First?</em> I refused to call the design "moves" I introduced "refactorings". Instead I used the diminutive "tidyings". I changed vocabulary because the word "refactoring" has drifted so far from its original definition &amp; had so much negative emotion glued to it that I wanted some distance.</p><p>I give up. The design changes you are about to read are refactorings, plain &amp; simple. There's no other word for them. Going back to Bill Opdyke's thesis (http://www.laputan.org/pub/papers/opdyke-thesis.pdf), that's what this scale of design transformation have been called.</p><p>Refactorings change the structure of the system rather than improve it. Each refactoring is reversible. Each can be applied in either direction--extract a function or inline a function. Depending on what you are trying to accomplish, one direction or the other will apply.</p><p>In a desperate attempt not to have my words misused, here is my definition of a refactoring:</p><ul><li><p>A change to the structure of the system,</p></li><li><p>To ease changes to the behavior of the system,</p></li><li><p>That preserves the observable behavior of the system.</p></li></ul><p>There's a difference between "refactoring" and "a refactoring". A refactoring is a single, atomic change to the structure. Refactoring the verb means to apply one or more refactorings in sequence to accomplish a larger change to the structure of the system.</p><p>I hear these stories all the time—"We spent all this time refactoring &amp; everything broke". That's <em>not</em> refactoring. If you compose a series of behavior-preserving transformations, the result will be behavior-preserving. The problem is that it can be hard to get from structure A to structure B solely by composing behavior-preserving transformations. Boo hoo.</p><p>Do I ever cheat &amp; just edit some text for a while? Reluctantly, yes. But that's by far the exception. Stretch yourself. <em>Only</em> use the refactorings in this section to get from the current structure to your desired structure. But I'm getting ahead of ourselves—this is material for the second section.</p><p>With that, here are the refactorings.</p><p>TODO list the refactorings when I'm done</p>