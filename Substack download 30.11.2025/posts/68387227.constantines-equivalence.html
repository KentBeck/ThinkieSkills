<p>I remember as a young programmer hearing dire reports that as much as 70% of software development costs went into maintenance. 70%! How poor a job must we be doing that we make a thing &amp; then have to spend twice as much just keeping it working?</p><p>Turns out that mental model of software, as a <em>_thing_</em> that is <em>_made_</em> &amp; then should run forever unchanged, like some kind of perpetual motion machine, is the opposite of what really happens and what <em>_should_</em> happen too. The future value of a system reveals itself in today’s realities, not yesterday’s speculation.</p><p>We are ready to understand coupling's significance. In the original work on coupling and cohesion, Structured Design by Edward Yourdon (of blessed memory) and Larry Constantine, they postulated that the goal of software design is to minimize the cost of software (it's also to maximize the value, but we'll get to that). If the goal is to minimize the cost of software, what costs are those?</p><p>That 70% turns out to be way low. If we apply our creativity, we can release value-creating software after only a few percent of its eventual development cost. It's in everyone's best interest to do so. The sooner we get feedback from real usage, the less time/money/opportunity we spend on behavior that doesn't matter.</p><p>The first term of what I've dubbed Constantine's Equivalence, then, is that the cost of software is approximately equal to the cost of changing it. Yes there is a brief period before we can be said to be "changing" it, but who cares? That period is economically insignificant.</p><blockquote><p>cost(software) ~= cost(change)</p></blockquote><p></p><div class="paywall-jump" data-component-name="PaywallToDOM"></div><p>What can we say about the cost of change? Are all changes equal? Of course no, not if I ask the question like that. We can bump along making small changes to the behavior of the system, all of them costing about the same. Then one day we make a change superficially similar to all the previous changes but this one blows up in our faces. Instead of costing one unit it costs ten or a hundred or a thousand.</p><p>If you know about power law distributions you recognize what's going on here (if you don't know about power law distributions, please be careful because I ended up obsessed about them for 20 years). One characteristic of power law distributions is that the "outlier" events cumulatively more than all the more-numerous tiny events--the 5 most expensive storms add up to far more than the 10,000 least expensive storms.<br>Is this sounding familiar? The most-expensive behavior changes cost, together, far more than all the least-expensive behavior changes put together. Put another way, the cost of change is approximately equal to the cost of the big changes.</p><blockquote><p>cost(change) ~= cost(big changes)</p></blockquote><p>What makes those expensive changes expensive? It's when changing this element requires changing those 2 elements, each of which require changing other elements, and... and... and... What "propagates" change? Coupling. So the cost of software is approximately equal to the coupling.</p><blockquote><p>cost(big changes) ~= coupling</p></blockquote><p>And now we have the full Constantine's Equivalence:</p><blockquote><p>cost(software) ~= cost(change) ~= cost(big changes) ~= coupling</p></blockquote><p>Or, to highlight the importance of software design:</p><blockquote><p>cost(software) ~= coupling</p></blockquote><p>To reduce the cost of software, we must reduce coupling. De-coupling isn't free &amp; it's subject to tradeoffs, which we explore next.</p>