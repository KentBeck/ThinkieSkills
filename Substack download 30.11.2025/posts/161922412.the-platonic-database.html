<p>I’ve been augmented coding several database projects, since they are 1) highly complex, 2) highly leveraged if successful, &amp; 3) sitting around in my brain. So far I have a key-value store cooking, an object database backend suitable for Meta’s TAO, and a persistent Smalltalk.</p><p>These projects got me thinking—what do we mean, in the abstract, when we say “database”?</p><p>I always visualized rows and columns, perhaps SQL statements or NoSQL document collections. But what are the abstract properties that make something a database? What's the essence of "database-ness"?</p><p>The systems I’ve been working on don’t need all the machinery of a traditional DBMS. Breaking things down to first principles often leads to insights about where and how to innovate. Here’s what I have so far.</p><h2>Stateful Put &amp; Get API</h2><p>The most fundamental property of a database is its stateful nature, expressed through basic put and get operations. After a put operation, what comes back from a subsequent get is different than before. This stateful interface distinguishes databases from pure functions or stateless services.</p><p>The beauty of this property is its simplicity. No matter how complex the implementation becomes, this core behavior of "I can put something in and later get it back" remains the defining characteristic of any database-like system.</p><h2>Constant(-sh) Time Put &amp; Get Operations</h2><p>Put &amp; get operations scale with the size of the data being changed, not with the total size of the database. Calling it O(1) over-simplifies a bit but makes the point that the performance isn’t connected to the total amount of data stored.  </p><ul><li><p>Put operations are O(size of the data being put). Inserting a 1KB record takes roughly the same time whether your database has 100 records or 100 million records.</p></li><li><p>Get operations are O(size of data fetched), but not O(size of all data). When you retrieve a single customer record, the operation doesn't need to scan through all customers.</p></li></ul><p>This scaling property is what allows databases to handle massive amounts of data while maintaining performance. Without it, databases would quickly become unusable as they grow.</p><h2>O(log n) I/O Operations</h2><p>In production, I/O is often the bottleneck. The number of I/O operations required for a get or put is O(log n), where n is the number of elements in the database. Reading or writing to a database with a billion records might require only 20-30 disk accesses, not a billion.</p><p>This logarithmic I/O behavior comes from clever data structures like B-trees and log structured merge trees that economize on disk access in the face of non-random key activity. </p><h2>Durability</h2><p>Once a put has completed, the next get will retrieve that value &amp; not some earlier value, even if the database crashes in between. (This ignores fun facts about concurrency, but Plato wrote single-threaded code so we won’t worry about that right now.)</p><p>The first implementation of durability is packing data on disk pages &amp; writing it to persistent storage. However, the complexity of the I/O optimizations mentioned above imply that sometimes the data on persistent pages lags the data that has been put.</p><p>Transaction logs improve durability. Rather than guarantee that eventually data that has been put will subsequently be gotten (“getted”?) (&amp; heaven help you if the system crashes before “eventually” comes), data is written to the transaction log &amp; flushed immediately &amp; synchronously.</p><p>This immediate memorization of data lets the database preserve the fiction of O(1) put performance. It also shortens the window of vulnerability to crashes. Once the call to flush the transaction log changes returns, the system is free to crash without damaging durability. The next time the system will come up, it will replay the changes from the transaction log before serving data.</p><h2>Constant(-ish) Startup Time</h2><p>Again, constant time over-simplifies. The key is that the database begins serving put &amp; get requests quickly regardless of data size.</p><p>This property distinguishes true databases from simple file-based persistence schemes. If your system has to read and process all data before it can handle the first query, it slows starting up as data grows.</p><p>What enables this property are clever data structures and algorithms - transaction logs, indexes that don't need to be fully loaded, and mechanisms that defer work until needed. Without constant-time startup, databases would be impractical for large datasets in production environments.</p><h2>WWPT—What Would Plato Think?</h2><p>When I'm trying to determine if something is truly a "database," I apply a simple test: Could I replace it with a traditional database without changing the semantics of the system? If yes, it's probably a database, even if it doesn't call itself one.</p><div class="captioned-image-container"><figure><a class="image-link image2 is-viewable-img" target="_blank" href="https://substackcdn.com/image/fetch/$s_!CBt-!,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F60f0dd73-ff1f-4558-94ba-73d38c4da9ab_2256x1827.jpeg" data-component-name="Image2ToDOM"><div class="image2-inset"><picture><source type="image/webp" srcset="https://substackcdn.com/image/fetch/$s_!CBt-!,w_424,c_limit,f_webp,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F60f0dd73-ff1f-4558-94ba-73d38c4da9ab_2256x1827.jpeg 424w, https://substackcdn.com/image/fetch/$s_!CBt-!,w_848,c_limit,f_webp,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F60f0dd73-ff1f-4558-94ba-73d38c4da9ab_2256x1827.jpeg 848w, https://substackcdn.com/image/fetch/$s_!CBt-!,w_1272,c_limit,f_webp,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F60f0dd73-ff1f-4558-94ba-73d38c4da9ab_2256x1827.jpeg 1272w, https://substackcdn.com/image/fetch/$s_!CBt-!,w_1456,c_limit,f_webp,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F60f0dd73-ff1f-4558-94ba-73d38c4da9ab_2256x1827.jpeg 1456w" sizes="100vw"><img src="https://substack-post-media.s3.amazonaws.com/public/images/60f0dd73-ff1f-4558-94ba-73d38c4da9ab_2256x1827.jpeg" width="1456" height="1179" data-attrs="{&quot;src&quot;:&quot;https://substack-post-media.s3.amazonaws.com/public/images/60f0dd73-ff1f-4558-94ba-73d38c4da9ab_2256x1827.jpeg&quot;,&quot;srcNoWatermark&quot;:null,&quot;fullscreen&quot;:null,&quot;imageSize&quot;:null,&quot;height&quot;:1179,&quot;width&quot;:1456,&quot;resizeWidth&quot;:null,&quot;bytes&quot;:718346,&quot;alt&quot;:&quot;platonic database is the combination of a tree of pages of data with an append-only transaction log&quot;,&quot;title&quot;:null,&quot;type&quot;:&quot;image/jpeg&quot;,&quot;href&quot;:null,&quot;belowTheFold&quot;:true,&quot;topImage&quot;:false,&quot;internalRedirect&quot;:&quot;https://tidyfirst.substack.com/i/161922412?img=https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F60f0dd73-ff1f-4558-94ba-73d38c4da9ab_2256x1827.jpeg&quot;,&quot;isProcessing&quot;:false,&quot;align&quot;:null,&quot;offset&quot;:false}" class="sizing-normal" alt="platonic database is the combination of a tree of pages of data with an append-only transaction log" title="platonic database is the combination of a tree of pages of data with an append-only transaction log" srcset="https://substackcdn.com/image/fetch/$s_!CBt-!,w_424,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F60f0dd73-ff1f-4558-94ba-73d38c4da9ab_2256x1827.jpeg 424w, https://substackcdn.com/image/fetch/$s_!CBt-!,w_848,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F60f0dd73-ff1f-4558-94ba-73d38c4da9ab_2256x1827.jpeg 848w, https://substackcdn.com/image/fetch/$s_!CBt-!,w_1272,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F60f0dd73-ff1f-4558-94ba-73d38c4da9ab_2256x1827.jpeg 1272w, https://substackcdn.com/image/fetch/$s_!CBt-!,w_1456,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F60f0dd73-ff1f-4558-94ba-73d38c4da9ab_2256x1827.jpeg 1456w" sizes="100vw" loading="lazy"></picture><div class="image-link-expand"><div class="pencraft pc-display-flex pc-gap-8 pc-reset"><button tabindex="0" type="button" class="pencraft pc-reset pencraft icon-container restack-image"><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-refresh-cw"><path d="M3 12a9 9 0 0 1 9-9 9.75 9.75 0 0 1 6.74 2.74L21 8"></path><path d="M21 3v5h-5"></path><path d="M21 12a9 9 0 0 1-9 9 9.75 9.75 0 0 1-6.74-2.74L3 16"></path><path d="M8 16H3v5"></path></svg></button><button tabindex="0" type="button" class="pencraft pc-reset pencraft icon-container view-image"><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-maximize2 lucide-maximize-2"><polyline points="15 3 21 3 21 9"></polyline><polyline points="9 21 3 21 3 15"></polyline><line x1="21" x2="14" y1="3" y2="10"></line><line x1="3" x2="10" y1="21" y2="14"></line></svg></button></div></div></div></a></figure></div><p></p><p>By this definition, many things have database-like qualities—file systems, key-value stores, even some message queues. The boundaries blur, especially as systems become more distributed.</p><h2>What This Means for Design</h2><p>Understanding these abstract properties helps me think about where I need a "real" database versus where I can use something lighter. It helps me recognize when I'm inadvertently building a database inside my application (usually a sign I should step back and reconsider).</p><p>Most importantly, it helps me see that "database" isn't a binary concept but a set of properties that exist to varying degrees in different systems. Each property solves specific problems, and I only need to pay for the ones my particular situation requires.</p><p>These core properties are what databases are truly selling. Everything else is implementation detail.</p><h2>The Properties: A Summary</h2><p>To recap, here are the fundamental properties that make something a true database:</p><ul><li><p>Stateful Put &amp; Get API—The system maintains state; what you get after a put is different from before.</p></li><li><p>Atomicity—Put operations either wholly succeed or wholly fail, guaranteed by the transaction log in O(1) time.</p></li><li><p>O(size of data) Operations—Put &amp; get running time scales with the size of data being handled, not total database size.</p></li><li><p>O(log n) I/O Operations—I/O operations scale logarithmically with database size, not linearly.</p></li><li><p>Transaction Logs for Performance and Durability—Logs keep put operations efficient while ensuring data survives crashes; recovery only requires replaying recent operations.</p></li><li><p>O(1) Startup Time—Startup time is constant regardless of database size.</p></li></ul><p>When you see these properties in a system, you're looking at a database—even if it doesn't call itself one.</p>