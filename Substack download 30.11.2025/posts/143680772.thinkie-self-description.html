<blockquote><p>I apologize for this coming out late. I had mis-scheduled an earlier Thinkie &amp; thought I already had this week covered.</p></blockquote><p>We are moving now into Thinkies that I call “models”. “Analogy” might be a better word. “If this were an X, then the logical consequences are Y &amp; Z.” There is power in stepping away from the situation as it appears literally &amp; thinking of it as something else. I get emotionally attached to my problems—I have a big problem I’m scared oh dear oh dear. Applying a model temporarily detaches my emotions from the situation. “If this is a queueing theory problem, then…” and I have a chance of getting out of my local minima (yes, optimization is one of these models—we’ll get to that later).</p><p>Pattern: you have a system that models other systems.</p><p>Transformation: use the system to model itself.</p><p>Examples:</p><ul><li><p>You have a design system that models user interfaces. Use it to model its own user interface.</p></li><li><p>You have a system that runs auctions. Use auctions to prioritize the next feature to be added to the auction system.</p></li><li><p>JUnit tested itself. (It was tricky to avoid breaking JUnit &amp; having it report all was well because it was broken.)</p></li></ul><p>Meta-circularity is as old as programming [ed: probably older? Examples?] It provides leverage 3 ways:</p><ul><li><p>If what you have is a good description of a system, having a good description of your own system is valuable.</p></li><li><p>If your description is poor, you’ll get rapid feedback of the holes.</p></li><li><p>Second order effects are extremely powerful. If you write an optimizing compiler  for a language in that language, every improvement to the optimizations makes the compiler faster &amp; enable you to make improvements faster.</p></li></ul>