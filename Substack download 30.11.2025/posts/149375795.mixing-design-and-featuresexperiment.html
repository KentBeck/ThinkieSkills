<blockquote><p>This chapter goes in the management section. It was going a bit long so I figured I’d give you the first half, get some feedback on it, then finish</p></blockquote><p>In <em>Tidy First? </em>we talked a lot about the timing of tidying. We had the "tidy first" flow, where design happened just before the implementation of a new feature. We had the "tidy after" flow, where design happened just after the annoyingly difficult implementation of a feature. Finally we had the rare "tidy because" flow, where design happened whenever because of curiosity or obsession or foresight.</p><p>When we move up to tidying together, we are faced with a more challenging, more ambiguous decision on timing. Here are some of the constraits:</p><ul><li><p>Design too soon &amp; we risk wasting time on speculation along with the degradation of net present value because of the features we delay.</p></li><li><p>Design too late &amp; we risk taking too long to implement the features relying on the design change.</p></li><li><p>Design too much &amp; the we risk losing the folks on the team that just want to implement features.</p></li><li><p>Design too little &amp; we degrade the optionality of the software.</p><p>In addition, tidying together takes longer. </p></li></ul><p>The kinds of design changes we make when tidying together take long enough that we have to interlace design investment &amp; feature investment. We can’t stop feature development for a noticeable period without damaging our relationship with customers &amp; business sponsors. We have to find a way to play the cymbals <em>&amp; </em>the drums.</p><p>How would you like teammates to make a design change? That’s (roughly) what you should do for them. If the change affects someone substantially &amp; immediately, invite them to be part of the change. If the change will affect them in the future, inform them.</p><p>Empirical software design doesn’t rely on unanimity. Everyone doesn’t, can’t, believe the same things or see things exactly the same way. We strive for coherence instead. While everyone has their own perspective on the design, we exert consistent effort to bring those perspectives together.</p><p>I’ll break this problem into 5 phases:</p><ul><li><p>Experimenting—how do we validate a design change before committing to it?</p></li><li><p>Initiating—how do we start a design change?</p></li><li><p>Sustaining—how do we continue making a design change while continuing to deliver features?</p></li><li><p>Abandoning—how do we responsibly abandon a design change?</p></li><li><p>Finishing—how do we complete a design change once most of the value has been wrung out of it?</p></li></ul><h2><strong>Experimenting</strong></h2><p>The is <em>Empirical </em>software design, after all, so we begin by experimenting. You think the code should be arranged like <em>this </em>instead of <em>that</em>? Rearrange a bit of the code &amp; see. Bonus points for doing it in a pair or a group. Extra bonus points for putting a time limit on the session.</p><p>An experiment should clarify whether the code will end up better after the change. If it’s still not clear, toss it &amp; start over.</p><p>I say, "...not clear," like that’s going to be universally shared. It won’t. Some folks will want to move in a new direction. Some won’t care. Others will oppose the change. That’s the nature of working as a team. How y’all resolve these conflicts predicts your success together.</p><p>Empirical software designers operate on evidence, not speculation. You experiment on speculation but don’t get attached. And software design being a, you guessed it, exercise in human relationships, you pay attention to relationships as you experiment. Two people disagree violently about direction? Have them experiment together, if they can stand it. That much energy should be put to good use.</p><p>One outcome of an experiment is that it is so successful &amp; so much easier than you expected that you’re done already. Hooray! Aren’t you glad you didn’t invest more time in arguments. Another is that after an hour with each approach, one is clearly superior. Or both parties feel heard &amp; they defer the change.</p><h2><strong>Initiating</strong></h2><p>There’s always a long list of things about the structure of the system that annoys those who have to live in the structure. We’d like the user interface to be more declarative. We’d like to be able to make some kinds of changes to the server without changing the interface. Or change the server without changing the database. Or the database without the server. Or change this file without having to change that file.</p><p>Initiating a design change is one of those classic problems that doesn’t yield to purely rational thought. The information necessary to make a rational initiation decision simply doesn’t exist when we decide:</p><p>• How long will it take?<br>• How much of the system will it touch?<br>• What kind of accidental breakage will we risk?<br>• How will the rest of the team react to the change?<br>• How much will the new design accelerate future features?<br>• What other design changes will be enabled or inhibited by this one?<br>• What other changes will we <em>not </em>be making because we’re making this one?</p><p>Only experience &amp; judgement give you a chance of making good initiation decisions, both "this is the direction we are going" &amp; "now is when we start". Remember that you aren’t just making these decisions for yourself. Software design is an exercise in human relationships (no, I’m not going to keep saying that).</p><p>I won’t say much about particular "this is the direction we are going" decisions. I’ll talk about them in principle, but I trust you to figure the details out. In my experience "now is when we start" is the more fraught decisions.</p><p>You might be making a design change too soon if:</p><ul><li><p>You haven’t yet experienced the coupling you are trying to avoid. Leaving a good design trick in your Bag of Design Tricks until later is a subtle but valuable skill for the Empirical Software Designer.</p></li><li><p>You are in one of those rare periods where the cost of delaying features is extremely high (e.g. coming up to a critical trade show).</p></li></ul><p>You aren’t sure which of several directions of change will pay off most. (Best to experiment briefly with all of them.)</p><p>(There’s a flip side, which is realizing that you waited too long. Not much to be done about that except making a note for next time.)</p><p>Call your shot. Announce what you intend to do. Don’t change the design in secret. (You can experiment in secret if necessary, but even that’s better as a team sport.)</p><p>Technically, the first thing to do is establish a parallel. This design change is going to go to production in many tiny pieces. You need to create a place for that to happen safely.</p><p>For instance, if you’re debuting a new API, introduce the new API:</p><pre><code>  OldAPI
    function operation()
  NewAPI
    function newOperation()
      OldAPI.operation()
</code></pre><p>That change should be completely safe, so push it to production just to be sure. (Thanks, Timothy Fitz!)</p><p>Duplicate the tests for the operation in the old API. They should all work. Push them to production too.</p><p>Now use the new API:</p><pre><code>  ...NewAPI.newOperation()...</code></pre><p>You don’t need to use it everywhere at once. Just one usage will validate the change you’re making. Remember, you’re being all empirical &amp; stuff.</p><p>What do you do if you have fancy (well, I’d say "essential", but folks seem to disagree) refactoring tools that enable you to change all the call sites at once? Maybe something like an abstract syntax tree rewriter? I’m shrugging here. Does it seem perfectly safe to change all the call sites at once?</p><p>Then try it. Big diffs can be small diffs if they only make one change in many places.</p><h2><strong>Sustaining</strong></h2>