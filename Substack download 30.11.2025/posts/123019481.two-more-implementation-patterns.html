<p><em>Originally published October 2007</em></p><p>Nested Method Objects and Conditional Factory helped simplify code in JUnit and make it more flexible.</p><h1>Introduction</h1><p>It never fails. No sooner do I finish a book than I think of ideas that would have been perfect to include. This time the book is <a href="https://amzn.to/3MNXED0">Implementation Patterns</a> and the ideas are two patterns: one I knew but forgot to include and the other I just encountered for the first time but that neatly extends a pattern in the book.</p><p>First I’ll set the stage a little. David Saff and I were refining JUnit. The code we were working on runs a single test method on a single test class instance. Before JUnit 4, the logic was simple:</p><p><code>protected void run(TestCase test) {<br>  startTest(test);</code><br>     <code>try {<br>    test.runBare();</code><br>     <code>} catch (Throwable e) {<br>    addError(test, e);</code><br>     <code>}</code><br>     <code>endTest(test);</code><br><code>}</code></p><p>In JUnit 4 running a test is no longer so simple. We gradually added several commonly implemented extensions—ignored tests, expected exceptions, and timeouts. To support all this functionality, we structured the code as a series of nested procedures, pairs of which took care of one aspect of running a test (thanks to <a href="https://structure101.com/">Structure 101</a> for the diagram):</p><div class="captioned-image-container"><figure><a class="image-link image2 is-viewable-img" target="_blank" href="https://substackcdn.com/image/fetch/$s_!IGZ3!,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Fe90b63e5-18b8-48f9-9226-30466362b3d1_476x389.jpeg" data-component-name="Image2ToDOM"><div class="image2-inset"><picture><source type="image/webp" srcset="https://substackcdn.com/image/fetch/$s_!IGZ3!,w_424,c_limit,f_webp,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Fe90b63e5-18b8-48f9-9226-30466362b3d1_476x389.jpeg 424w, https://substackcdn.com/image/fetch/$s_!IGZ3!,w_848,c_limit,f_webp,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Fe90b63e5-18b8-48f9-9226-30466362b3d1_476x389.jpeg 848w, https://substackcdn.com/image/fetch/$s_!IGZ3!,w_1272,c_limit,f_webp,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Fe90b63e5-18b8-48f9-9226-30466362b3d1_476x389.jpeg 1272w, https://substackcdn.com/image/fetch/$s_!IGZ3!,w_1456,c_limit,f_webp,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Fe90b63e5-18b8-48f9-9226-30466362b3d1_476x389.jpeg 1456w" sizes="100vw"><img src="https://substack-post-media.s3.amazonaws.com/public/images/e90b63e5-18b8-48f9-9226-30466362b3d1_476x389.jpeg" width="476" height="389" data-attrs="{&quot;src&quot;:&quot;https://substack-post-media.s3.amazonaws.com/public/images/e90b63e5-18b8-48f9-9226-30466362b3d1_476x389.jpeg&quot;,&quot;srcNoWatermark&quot;:null,&quot;fullscreen&quot;:null,&quot;imageSize&quot;:null,&quot;height&quot;:389,&quot;width&quot;:476,&quot;resizeWidth&quot;:null,&quot;bytes&quot;:null,&quot;alt&quot;:&quot;&quot;,&quot;title&quot;:null,&quot;type&quot;:null,&quot;href&quot;:null,&quot;belowTheFold&quot;:false,&quot;topImage&quot;:true,&quot;internalRedirect&quot;:null,&quot;isProcessing&quot;:false,&quot;align&quot;:null,&quot;offset&quot;:false}" class="sizing-normal" alt="" title="" srcset="https://substackcdn.com/image/fetch/$s_!IGZ3!,w_424,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Fe90b63e5-18b8-48f9-9226-30466362b3d1_476x389.jpeg 424w, https://substackcdn.com/image/fetch/$s_!IGZ3!,w_848,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Fe90b63e5-18b8-48f9-9226-30466362b3d1_476x389.jpeg 848w, https://substackcdn.com/image/fetch/$s_!IGZ3!,w_1272,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Fe90b63e5-18b8-48f9-9226-30466362b3d1_476x389.jpeg 1272w, https://substackcdn.com/image/fetch/$s_!IGZ3!,w_1456,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Fe90b63e5-18b8-48f9-9226-30466362b3d1_476x389.jpeg 1456w" sizes="100vw" fetchpriority="high"></picture><div class="image-link-expand"><div class="pencraft pc-display-flex pc-gap-8 pc-reset"><button tabindex="0" type="button" class="pencraft pc-reset pencraft icon-container restack-image"><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-refresh-cw"><path d="M3 12a9 9 0 0 1 9-9 9.75 9.75 0 0 1 6.74 2.74L21 8"></path><path d="M21 3v5h-5"></path><path d="M21 12a9 9 0 0 1-9 9 9.75 9.75 0 0 1-6.74-2.74L3 16"></path><path d="M8 16H3v5"></path></svg></button><button tabindex="0" type="button" class="pencraft pc-reset pencraft icon-container view-image"><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-maximize2 lucide-maximize-2"><polyline points="15 3 21 3 21 9"></polyline><polyline points="9 21 3 21 3 15"></polyline><line x1="21" x2="14" y1="3" y2="10"></line><line x1="3" x2="10" y1="21" y2="14"></line></svg></button></div></div></div></a></figure></div><p>This code worked in the sense that it passed all the tests, although some of the intervening layers were quite complicated. The camel’s back snapped when people (us included) began writing custom runners. Most people running a single test method want most or all of the default functionality with some additions or alterations. Figuring out which methods to override and when to invoke superclass methods was complicated, time consuming, and error prone. We were failing to provide ease of extension, one of our primary goals for JUnit 4.</p><h1>Nested Method Object</h1><p>The Method Object implementation pattern suggests turning a complex method into an object to enable further simplification. In its original form it doesn’t apply to the code above, since the complexity mostly comes from the relationship of the methods, not from the methods themselves. A twist on Method Object, however, seems to have provided us with clarity and flexibility. The key was to have a chain of method objects, roughly one for every two levels of the call graph above. Here is a picture of the default chain of instances:</p><div class="captioned-image-container"><figure><a class="image-link image2" target="_blank" href="https://substackcdn.com/image/fetch/$s_!pxHo!,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F6b97d9eb-a3a2-48c0-8440-c1f56548d3d4_401x170.gif" data-component-name="Image2ToDOM"><div class="image2-inset"><picture><source type="image/webp" srcset="https://substackcdn.com/image/fetch/$s_!pxHo!,w_424,c_limit,f_webp,q_auto:good,fl_lossy/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F6b97d9eb-a3a2-48c0-8440-c1f56548d3d4_401x170.gif 424w, https://substackcdn.com/image/fetch/$s_!pxHo!,w_848,c_limit,f_webp,q_auto:good,fl_lossy/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F6b97d9eb-a3a2-48c0-8440-c1f56548d3d4_401x170.gif 848w, https://substackcdn.com/image/fetch/$s_!pxHo!,w_1272,c_limit,f_webp,q_auto:good,fl_lossy/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F6b97d9eb-a3a2-48c0-8440-c1f56548d3d4_401x170.gif 1272w, https://substackcdn.com/image/fetch/$s_!pxHo!,w_1456,c_limit,f_webp,q_auto:good,fl_lossy/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F6b97d9eb-a3a2-48c0-8440-c1f56548d3d4_401x170.gif 1456w" sizes="100vw"><img src="https://substack-post-media.s3.amazonaws.com/public/images/6b97d9eb-a3a2-48c0-8440-c1f56548d3d4_401x170.gif" width="401" height="170" data-attrs="{&quot;src&quot;:&quot;https://substack-post-media.s3.amazonaws.com/public/images/6b97d9eb-a3a2-48c0-8440-c1f56548d3d4_401x170.gif&quot;,&quot;srcNoWatermark&quot;:null,&quot;fullscreen&quot;:null,&quot;imageSize&quot;:null,&quot;height&quot;:170,&quot;width&quot;:401,&quot;resizeWidth&quot;:null,&quot;bytes&quot;:null,&quot;alt&quot;:&quot;&quot;,&quot;title&quot;:null,&quot;type&quot;:null,&quot;href&quot;:null,&quot;belowTheFold&quot;:true,&quot;topImage&quot;:false,&quot;internalRedirect&quot;:null,&quot;isProcessing&quot;:false,&quot;align&quot;:null,&quot;offset&quot;:false}" class="sizing-normal" alt="" title="" srcset="https://substackcdn.com/image/fetch/$s_!pxHo!,w_424,c_limit,f_auto,q_auto:good,fl_lossy/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F6b97d9eb-a3a2-48c0-8440-c1f56548d3d4_401x170.gif 424w, https://substackcdn.com/image/fetch/$s_!pxHo!,w_848,c_limit,f_auto,q_auto:good,fl_lossy/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F6b97d9eb-a3a2-48c0-8440-c1f56548d3d4_401x170.gif 848w, https://substackcdn.com/image/fetch/$s_!pxHo!,w_1272,c_limit,f_auto,q_auto:good,fl_lossy/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F6b97d9eb-a3a2-48c0-8440-c1f56548d3d4_401x170.gif 1272w, https://substackcdn.com/image/fetch/$s_!pxHo!,w_1456,c_limit,f_auto,q_auto:good,fl_lossy/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F6b97d9eb-a3a2-48c0-8440-c1f56548d3d4_401x170.gif 1456w" sizes="100vw" loading="lazy"></picture><div></div></div></a></figure></div><p>By first creating the chain of method objects and then executing them, we give ourselves and potential extenders the chance to create different chains. By replacing, augmenting, or reordering the links in the chain, different test runners can achieve different test running behavior while easily picking up the necessary bits of the default behavior.</p><p>We have had some trouble picking names for these objects. They help run test methods, so TestMethodRunnerHelper makes some sense, but it’s a long and awkward name (see Simple Superclass in Implementation Patterns for more discussion of class naming). For the moment, we have followed the chain metaphor and called the base class Link. The problem is that the metaphor is so generic—“Link” gives readers no clue about the purpose of the chain, just that it is a chain. When we have more experience with the concept, I expect we’ll find a better name.</p><p>Another way to look at this design is as an example of Decorator, where the Links are decorators. If we had designed this functionality from scratch as a nested series of objects, we could have gotten to the design that way. However, nested procedures worked pretty well for years, so we had no motivation to objectify them. Even though the final design is the same, it still makes sense to me to have different patterns to describe the different paths to reach that design.</p><p>Recasting the method running logic as objects gave us a chance to simplify the flow of control and eliminate some nagging duplication. This is a common consequence of method objects but it was a bit surprising to see it at work in a chain of method objects. We also found other ways to simplify the code, which leads to…</p><h1>Conditional Factory</h1><p>Not every test method uses every feature represented by the nested methods objects. The original methods were sprinkled with conditionals to decide whether to apply a feature:</p><p><code>if (fTestMethod.getTimeout() &gt; 0) {</code><br>    <code>// process the timeout</code><br><code>} else {</code><br>    <code>// just run the method</code><br><code>}</code></p><p>Recasting the logic as objects let us use one of my favorite patterns, one that I just flat out forgot to include in the book. The idea is to move conditional code like that above into a constructor, producing different kinds of objects representing the different cases. Following this, the code in the objects can become simpler because it can assume that the condition holds (or doesn’t hold).</p><p>Java constructors only return instances of the concrete class on which they are invoked, so some for of indirection is needed to implement this idea in Java. In this case, we used a variant on the Internal Factory pattern, Conditional Factory. Rewriting the code above as a conditional factory yields:</p><p><code>public Link timeout(Link next) {</code><br>    <code>return fTestMethod.getTimeout() &gt; 0</code><br>        <code>? new Timeout(next)</code><br>        <code>: next;</code><br><code>}</code></p><p>In other words, only add a Timeout to the chain if its work is necessary. This allows the logic in Timeout to be several lines shorter because it need only work in the case where there is a timeout attribute attached to a test method.</p><p>The above example is an unusual conditional factory in my experience. Usually a conditional factory will return one of two (or more) classes. This appears also in our refactored code:</p><p><code>public Link handleExceptions(Link next) {</code><br>    <code>return fTestMethod.expectsException()</code><br>        <code>? new ExpectedException(next)</code><br>        <code>: new NoExpectedException(next);</code><br><code>}</code></p><p>Conditional factories are good for simplifying code where the two legs of the conditional have little in common. Otherwise it’s probably better to keep the conditional in the main flow of control and use the usual methods to share implementation.</p><h1>Conclusion</h1><p>One lesson of this episode for me is that there are always tricks to learn. Having just spent three years thinking about and writing about implementation patterns, I didn’t expect to find a new one. Silly me. I still don’t expect to see nested method objects every day, but I’m glad I know the pattern now because it did a lot to simplify a complicated situation.</p><p>Another lesson I learned is not to expect books to stay finished long, although I wish they lasted long enough to hit the shelves. Remember this as a reader—whatever you are reading is only a snapshot of an ongoing process of learning on the part of the author.</p><p>Finally, I learned to keep trying when refactoring. Several times during this refactoring episode either David or I were stuck. Sometimes taking a break was all that was necessary to shake the needed idea loose, sometimes it was talking with each other that did the trick, and sometimes it required passing off responsibility for the code. I wonder how many potentially valuable refactorings stall before they reach a payoff. Since we work on an open source project without deadlines or paying customers, we can see our ideas through to completion. When coding commercially I sometimes stop refactoring to finish this week’s functionality [ed: foreshadowing Tidy First here]. Being aware of the tradeoffs will help me make an informed decision about how far to push refactorings.</p><h1>Acknowledgements</h1><p>I’d like to thank David Saff for getting into this mess with me and being willing to work out of it.</p>