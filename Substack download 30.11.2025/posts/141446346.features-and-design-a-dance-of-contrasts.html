<blockquote><p>I’d love your feedback on this (and all) chapters. I wrote this believing that executives could create more value with software projects if they understood the strategic importance of software design. Of course, I <em>would</em> say that. I’m a geek. If you’re an executive &amp; reading this, don’t miss out on future chapters by subscribing below.</p><p class="button-wrapper" data-attrs="{&quot;url&quot;:&quot;https://tidyfirst.substack.com/subscribe?coupon=d52f030d&amp;utm_content=141446346&quot;,&quot;text&quot;:&quot;Get 20% off forever&quot;,&quot;action&quot;:null,&quot;class&quot;:null}" data-component-name="ButtonCreateButton"><a class="button primary" href="https://tidyfirst.substack.com/subscribe?coupon=d52f030d&amp;utm_content=141446346"><span>Get 20% off forever</span></a></p></blockquote><p>Programming isn’t just programming, any more than maple syrup &amp; mustard are just condiments. They are useful in different contexts. You can’t just substitute one for the other, nor mix them together &amp; expect to get something delicious.</p><p>Changes within a software system can be likened to two distinct types of dance steps: those that alter the performance for the audience (behavior changes) and those that refine the dancers' choreography backstage (structure changes). Understanding the distinction, knowing which to emphasize at the moment, &amp; avoiding mixing them are all skills executives can exercise to enhance the value of their software products.</p><p><strong>Behavior Changes: Features for the Audience</strong></p><p>Behavior changes in software are observable modifications that impact how users interact with the system. These can range from new features, such as a button that does something, to optimizations that streamline operations or reduce costs. Each behavior change should lead to an improvement in the Net Present Value (NPV) of the software, either by boosting revenue or cutting expenses.</p><p>For example, introducing a new payment option could directly increase sales, while optimizing an algorithm might reduce server costs. These changes are the front-line soldiers in the battle for market share and profitability. They’re visible, tangible, and directly tied to the software’s economic outcomes.</p><p><strong>Structure Changes: The Choreography Behind the Scenes</strong></p><p>Contrastingly, structure changes are the internal reorganizations of the software’s architecture. These alterations don’t directly affect the cash flow or the user’s immediate experience but have a profound impact on the software’s future adaptability and efficiency. Improving the software’s structure enhances its optionality, making it easier to implement new behavior changes down the line.</p><p>Think of structure changes as investing in a more versatile stage for our dancers. This new stage doesn’t change the current performance but makes it significantly easier to adapt or enhance future shows. While these modifications don’t directly translate to immediate NPV improvements, they amplify the value of the software by preserving and expanding its future possibilities.</p><p>Structure changes do improve NPV, by reducing the cost of future features &amp; bringing those features to market sooner. This introduces a tradeoff:<br>* Design more now for the promise of future improvement?<br>* Implement features now, even at a cost to the structure of the system &amp; thus a sacrifice of future NPV?</p><p>The information required to make this tradeoff perfectly rationally simply doesn’t exist at the moment you have to decide, so judgement, principles, &amp; hedging are all required to maintain balance. You as an executive have broader perspective than the individuals involved, even though</p><p>8</p><p>you have less detailed information.</p><p><strong>The Reversibility of Structure Changes</strong></p><p>A key aspect that differentiates structure changes from behavior changes is their reversibility. Structure changes, being internal, can often be undone with minimal fallout, allowing for a more experimental approach. If a new architectural pattern doesn’t yield the expected improvements, reverting to the previous state is usually straightforward, quick, and cost-effective.</p><p>Behavior changes, on the other hand, are akin to a live performance; once you’ve changed the script and performed in front of the audience, there’s no simple undo button. The stakes are higher, and the cost of reversal, both in terms of resources and reputation, can be significant. This is why behavior changes necessitate rigorous testing—to ensure that new features perform as intended.</p><p><strong>Encouraging a Dual Approach</strong></p><p>The distinct risk profiles of behavior and structure changes imply that they require different management strategies. For behavior changes, thorough testing and validation ensure that the new or altered behavior performs as expected and does not introduce unforeseen issues.</p><p>For structure changes, while testing remains important, there’s more room for exploration and iteration, given their reversible nature. Encouraging your teams to clearly distinguish between these two types of changes fosters a more nuanced approach to software development, where both the immediate performance and the long-term agility of the system are optimized.</p><p>In a given year, of course you’ll see some feature work &amp; some structure work. Same in a given month. In a given day, one or the other may predominate. Encourage teams to steer a little this way, a little that way, &amp; to not mix behavior &amp; structure changes.</p><p><strong>Conclusion</strong></p><p>As we delve deeper into the nuances of software development, it’s clear that the separation of structure and behavior changes is not just a technicality but a strategic approach to enhancing software value. By understanding and leveraging this distinction, technology executives can guide their teams toward decisions that not only improve the software’s current state but also secure its adaptability and success in the future.</p><p>But our exploration does not end here. The decisions we make about behavior and structure changes are deeply intertwined with the underlying technical factors that drive the cost and complexity of software. As we look ahead, we are poised to delve into the foundational concepts of coupling and cohesion—two critical technical drivers that significantly influence the cost of software development.</p>