<p>“Won’t incremental design get you into corners you can’t get out of?” There’s always that risk with any style of design, but here’s an example of why I don’t worry about when I’m designing incrementally.</p><h2>MCETMEC</h2><p>Thirteen years ago now I said this:</p><div class="captioned-image-container"><figure><a class="image-link image2" target="_blank" href="https://substackcdn.com/image/fetch/$s_!kqvK!,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F12131d35-a358-4583-9373-e3ae4f5e5a87_571x164.png" data-component-name="Image2ToDOM"><div class="image2-inset"><picture><source type="image/webp" srcset="https://substackcdn.com/image/fetch/$s_!kqvK!,w_424,c_limit,f_webp,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F12131d35-a358-4583-9373-e3ae4f5e5a87_571x164.png 424w, https://substackcdn.com/image/fetch/$s_!kqvK!,w_848,c_limit,f_webp,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F12131d35-a358-4583-9373-e3ae4f5e5a87_571x164.png 848w, https://substackcdn.com/image/fetch/$s_!kqvK!,w_1272,c_limit,f_webp,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F12131d35-a358-4583-9373-e3ae4f5e5a87_571x164.png 1272w, https://substackcdn.com/image/fetch/$s_!kqvK!,w_1456,c_limit,f_webp,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F12131d35-a358-4583-9373-e3ae4f5e5a87_571x164.png 1456w" sizes="100vw"><img src="https://substack-post-media.s3.amazonaws.com/public/images/12131d35-a358-4583-9373-e3ae4f5e5a87_571x164.png" width="571" height="164" data-attrs="{&quot;src&quot;:&quot;https://substack-post-media.s3.amazonaws.com/public/images/12131d35-a358-4583-9373-e3ae4f5e5a87_571x164.png&quot;,&quot;srcNoWatermark&quot;:null,&quot;fullscreen&quot;:null,&quot;imageSize&quot;:null,&quot;height&quot;:164,&quot;width&quot;:571,&quot;resizeWidth&quot;:null,&quot;bytes&quot;:27195,&quot;alt&quot;:null,&quot;title&quot;:null,&quot;type&quot;:&quot;image/png&quot;,&quot;href&quot;:null,&quot;belowTheFold&quot;:false,&quot;topImage&quot;:true,&quot;internalRedirect&quot;:&quot;https://tidyfirst.substack.com/i/162717906?img=https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F12131d35-a358-4583-9373-e3ae4f5e5a87_571x164.png&quot;,&quot;isProcessing&quot;:false,&quot;align&quot;:null,&quot;offset&quot;:false}" class="sizing-normal" alt="" srcset="https://substackcdn.com/image/fetch/$s_!kqvK!,w_424,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F12131d35-a358-4583-9373-e3ae4f5e5a87_571x164.png 424w, https://substackcdn.com/image/fetch/$s_!kqvK!,w_848,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F12131d35-a358-4583-9373-e3ae4f5e5a87_571x164.png 848w, https://substackcdn.com/image/fetch/$s_!kqvK!,w_1272,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F12131d35-a358-4583-9373-e3ae4f5e5a87_571x164.png 1272w, https://substackcdn.com/image/fetch/$s_!kqvK!,w_1456,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F12131d35-a358-4583-9373-e3ae4f5e5a87_571x164.png 1456w" sizes="100vw" fetchpriority="high"></picture><div></div></div></a></figure></div><p>Maybe I would tweak the wording a bit (“for each *hard* change” has better parallelism), but I stand by the thought. Folks loved this saying, I think because it made it sound like programming was going to be easier. Turns out that while it’s easier, it isn’t easy, &amp; because of that parenthetic warning.</p><p>But what’s this “making it easier” that “may be hard”. Here’s an example.</p><h2>Big Coupling</h2><p>One of my ridiculously ambitious augmented coding projects is a from-scratch reimplementation of Smalltalk. One version of the virtual machine is a bytecode interpreter written in Go. I hadn’t used Go before, so I let the genie make its own design decisions. A mistake, but a forgivable one. (I forgive me, anyway. YMMV.)</p><p>I have a struct for objects. All through the code I passed parameters typed as *Object. What could be wrong with that?</p><p>The problem came when I wanted to vary the layout of subclasses. I needed to have an interface that all these variants of structs could adhere to so I could treat them generically for most of the code &amp; downcast them for special cases once I knew I was dealing with, for example, a Class or a Method.</p><h2>Hard Change</h2><p>My first thought was to enlist my coding genie to climb itself out of the hole it dug. I asked it to convert all references to *Object to ObjectInterface. I popped some popcorn &amp; sat down to watch. Sat down to watch the number of compile errors grow. And grow. And grow. Each attempted fix made the problem list longer. After a while it was clear that this pit of despair was too deep for the genie’s powers to escape.</p><p></p><p></p>