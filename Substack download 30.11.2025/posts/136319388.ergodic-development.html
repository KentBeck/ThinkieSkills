<blockquote><p>Whether you're a brother or whether you're a mother<br>You're stayin' alive, stayin' alive<br>Feel the city breakin' and everybody shakin'<br>And we're stayin' alive, stayin' alive<br>Ah, ha, ha, ha, stayin' alive, stayin' alive<br>Ah, ha, ha, ha, stayin' alive<br>    — BeeGees</p></blockquote><p>Ergodicity reminds us to divide our systems into:</p><ul><li><p>Those that tend to continue roughly as is, regardless of perturbations (ergodic)</p></li><li><p>Those that experience Game Over in response to change (non-ergodic—<a href="https://tidyfirst.substack.com/p/ergodic-good-thinkie-awful-name">not a great name</a>)</p></li></ul><p>Treat these 2 flavors of systems very differently. Treat Game Over systems gingerly, as there is no going back once they are gone.</p><p>Non-ergodic systems can be exhausting to manage, so<span class="mention-wrap" data-attrs="{&quot;name&quot;:&quot;Luca Dellanna&quot;,&quot;id&quot;:7012085,&quot;type&quot;:&quot;user&quot;,&quot;url&quot;:null,&quot;photo_url&quot;:&quot;https://substack-post-media.s3.amazonaws.com/public/images/ce2ffe3f-ad8e-4c41-a542-87167a4f0c4c_500x500.png&quot;,&quot;uuid&quot;:&quot;d94ce05d-7874-42c6-b5a8-5ef4960bcd7f&quot;}" data-component-name="MentionToDOM"></span>, in his lovely short book <em>Ergodicity</em>, offers 3 general strategies for transforming Game Over systems into sustaining systems:</p><ul><li><p>Reduce exposure to irreversibility</p></li><li><p>Skin in the game</p></li><li><p>Load redistribution</p></li></ul><p>What would happen if we applied these strategies to software development? (Hint, it’s going to end up looking a lot like XP. Hope you aren’t surprised.)</p><h2>Ergodic Development</h2><p>What follows assumes that we want the software development project to survive. Which is true, economically. At one point the OS/360 PL/1 compiler was bringing in $300m annually with a team of 3 people to support it. Ergodicity can be ridiculously profitable.</p><h3>More Reversibility</h3><p>We would plan &amp; execute in smaller cycles so decisions would be cheaper. Go the wrong direction for a week? Monday it’s a new game. Push the design the wrong direction? Throw the change away &amp; start over. The change we made would have caused errors in production? Glad we found out now before any damage was done.</p><p>All this insurance we pay for is going to seem expensive. But, as always, compared to what? It’s expensive compared to the universe in which we just do the right thing the first time. Unfortunately (or fortunately) we don’t live in that universe.</p><h3>Skin In The Game</h3><p>Making sure consequences flow to actors creates value 2 ways:</p><ul><li><p>Encourages good behavior</p></li><li><p>Discourages bad behavior</p></li></ul><p>If we want skin in the game in our software project we will:</p><ul><li><p>Programmers are on call for production support.</p></li><li><p>Programmers test their own changes, tests they are responsible for keeping healthy.</p></li><li><p>Everyone sits together (or is on frequent video calls) so user problems are immediately experienced by those who caused the problems.</p></li><li><p>Software designers who make changes are also responsible for helping those affected by those changes.</p></li><li><p>Ideally, the team uses the product in their daily work.</p></li></ul><p>In each of these cases, we are doing “extra” work. The folks with skin in the game could go faster if they didn’t have skin in the game. However, lack of feedback feeds risk of Game Over. Survival over optimization.</p><h3>Load Redistribution</h3><p>We would have a big enough team serving a wide enough variety of needs that when any one of those needs spiked we could quickly add attention to it. We would encourage migration across teams so if one team experienced a spike we could quickly augment it. We would encourage cross-specialty collaboration so no one kind of task would become a bottleneck.</p><p>In what is becoming a theme, preparing to redistribute load costs more than maintaining silos. We don’t mind paying the price, though, because we care about survival. We want to make non-ergodic, Game Over, development as ergodic as possible.</p><h2>And Next…</h2><p>When I had the idea for this essay I thought it would end up being more complete. Instead I have just barely started applying the lessons of ergodicity to software development. Read the book. Apply it yourself. Comment.</p><blockquote><p>Meta-Cognitive Note—you’ll notice I’ve been applying ergodicity a bunch of different ways recently. This is a habit, both for me &amp; the most successful of my coaching students. When you get a new idea, try over-apply it. That’s the only way you’ll find the boundaries of its application.</p></blockquote><p></p>