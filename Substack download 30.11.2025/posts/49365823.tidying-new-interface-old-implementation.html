<p>[I'm likely to delete this tidying because it is rarer &amp; less clear. If you find it helpful, lmk &amp; I'll leave it in. Iâ€™m sending it out to all subscribers because I need an example.]</p><p>So you need to call a routine &amp; the interface makes it difficult/complicated/confusing/tedious. Implement the interface you wish you could call &amp; call it. Implement the new interface by simply calling the old one (you can inline the implementation later after migrating all other callers).</p><p>Creating a pass-through interface is the micro-scale essence of software design. I want to make some behavior change. If the design was like thus and so, making that change would be easy(-er). So make the design like that.</p><p>The same impulse is true whether we are: </p><ul><li><p>Coding backwards--start with the last line of a routine as if you already had all the intermediate results you needed. </p></li><li><p>Coding test-first--start with the test that needs to pass. </p></li><li><p>Designing helpers--if only I had a routine, object, service that did XXX then the rest of this would be easy.</p></li></ul><p>[really really needs an example]</p>