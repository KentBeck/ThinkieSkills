<blockquote><p>This article was first published in 2022. It has become newly relevant because remote development environments turn out to be key enabling infrastructure for remote genies.</p></blockquote><p>When I joined Gusto 3 and a half years ago I got to program production Ruby for the first time. I was excited to get started. Alex, a senior developer, walked me through the steps required to get tests &amp; an IDE running on my laptop. All was well for a few days.</p><p>Then I updated the repository &amp; the tests wouldn’t run. “Oh, yeah,” Alex said, “You have to delete this file &amp; re-run that script. No problem.” I did. No problem.</p><p>Come the next Monday, though, it was, “Hmmm, I haven’t seen this before.” Type type type. “Let me ask somebody.” Type type type. “There, all fixed.”</p><p>Every few days, my development environment got borked. Often it was a quick fix. Sometimes not. But always time taken from one of the most productive programmers (Alex, not me.)</p><div><hr></div><p><em>Welcome to new sponsor <strong><a href="https://fnf.dev/46Jc55M">CodeRabbit</a></strong>. As I continue to write more code with AI, I long for a "what all did the genie do?" tool.</em></p><p><em>CodeRabbit offers this visibility, providing code reviews right in the IDE (for individual coding insights) and on PRs (to ensure consistency and quality across your org). CodeRabbit fits into existing toolchains and git-based workflows, can be personalized for individuals and teams, and can be used in conjunction with some of our favorite AI agents (including Claude Code, Augment Code, Cline, etc.).</em></p><p><em><a href="https://fnf.dev/46Jc55M">Sign up today</a> and see how CodeRabbit can cut bugs and review time in half (while also letting you keep tabs on your augmented coding projects).</em></p><div><hr></div><h2><strong>Structural Problem</strong></h2><p>Developers spend hours a week just being able to program on laptops. Laptops have advantages as a programming location: control, latency, flexibility. However, we just don’t seem to be able to keep them working without leaving the floor covered in yak hair. We’re programmers. Can’t we just solve this problem?</p><p>No. As I was getting acquainted with GitPod the other day, it struck me that there is no direct way around the problem of a stable, predictable development environment on a personal machine.</p><h2><strong>Variability, Interconnection, State, Irreversibility</strong></h2><p>I learned the following model from Professor Enrico Zaninotto, at the time the Dean of Economics at the University of Trento. Large, complicated system aren’t controllable when they combine 4 properties:</p><ul><li><p>Variability — the environment around the system changes out of control &amp; visibility of the system.</p></li><li><p>Interconnection — the elements in the environment affect each other.</p></li><li><p>State — the system can be in one of many states at any given time.</p></li><li><p>Irreversibility — changes to the system, once made, cannot easily be unmade.</p></li></ul><p>When all 4 properties are present, there is no way of predicting how the system will behave. Change the system, there is no way of predicting how the overall behavior will change. You can’t understand the system well enough to fix this problem.</p><p>His first example was mass production gaining control by reducing the number of states. All Model T Fords were black not because Henry Ford liked black so much, but because “paint or no paint” is easier to manage than “how much of each color of paint to do we have/need?”.</p><p>(Professor Zaninotto was trying to understand the effectiveness of Extreme Programming. Software development has all 4 properties. <a href="https://www.facebook.com/notes/681695435785808/">XP, in this model, works by introducing reversibility to software development decisions.</a>)</p><h2><strong>Applied to Development Environments</strong></h2><p>How does this model apply to development environments?</p><ul><li><p>Variability — Yes. Today’s style of development takes advantage of a long &amp; complicated supply chain. All the systems we rely on change independently.</p></li><li><p>Interconnection — Yes. The parts of our system rely on each other.</p></li><li><p>State — Oh my yes. The current state of a development environment is enormous. What’s been downloaded, initialized, running, messed up?</p></li><li><p>Irreversibility — Surprisingly, yes. “Oh, upgrading this messed up that? Just reinstall the previous version.” Yeah, right.</p></li></ul><p>How does this help with my Monday morning laptop blues? We still want to take advantage of variability. We aren’t Forth programmers writing all of our own stack down to silicon. We can’t avoid interconnection.</p><p>That leaves us with state and irreversibility. Pre-built development environments of the sort offered by GitPod give everyone using the same environment the exact same state. If today’s pre-build doesn’t work, we can easily load yesterday’s &amp; get back to a known-good environment.</p><h2><strong>And Then…</strong></h2><p>I’m excited to see how this plays out. The first advantage for programmers is the time they save. I’ve seen different numbers for the current cost of keeping a development environment working, but it’s certainly tens of percent.</p><p>More important, I suspect, will be all the programs that folks will try writing because they are no longer afraid of wasting another 4 hours before giving up. One of those programs that wouldn’t have been started will turn out to be exceedingly valuable.</p><p>Interesting problems remain. How does remote development retain the latency of local development? How do you share a remote environment? How do you satisfy the needs of beginner, intermediate, &amp; expert programmers at the same time?</p>