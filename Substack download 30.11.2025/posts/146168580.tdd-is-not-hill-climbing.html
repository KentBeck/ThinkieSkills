<p><a href="https://rahem027.gitlab.io/blogs/tdd-cannot-work.html">This post</a> puts forward the intriguing argument that TDD is a hill climbing algorithm &amp; therefore subject to getting stuck in a local maximum. That is, according to this argument, there are valid states of code that can’t be reached one test case at a time. (The post uses the clickbait title “TDD Cannot Work”, which is over-reach on the author’s part.)</p><p>The argument as put forward is full of logical holes, but it points to an interesting question—can we characterize kinds of problems best approached some other way than TDD? If we could identify such problems up front, we could save time &amp; effort.</p><h2>Statement &amp; Question</h2><p>I have a statement &amp; a question. Start with the statement. When we say, “TDD is a hill climbing algorithm,” we are making an analogy. As with all analogies, insight flows from the play of “is” and “is not”. TDD kind of is a hill climbing algorithm. TDD is also kind of not a hill climbing algorithm. The ways it’s similar &amp; the ways it’s different may teach us something about TDD (and maybe a little something about hill climbing).</p><p>First, the argument is flawed as presented. Just as well say, “Coding the whole algorithm at once is hill climbing. We write one line first &amp; then all the rest of the lines. There are valid program states we cannot reach this way.” This is clearly specious.&nbsp;</p><p>The analogy between TDD as a way to move between program states &amp; a text editor as a way to move between program states is inexact. The text editor [editor: why are we still manipulating code as a 1 dimensional array of characters wrapped into a 2 dimensional array of characters?] doesn’t constrain what we do next. We could type the program in back-to-front if we wanted to.</p><p>TDD, on the other hand, imposes constraints on motion between program states. If we have a red test we can only (in canonical TDD) change the code to make the test pass. If all the tests pass, we can either:</p><ul><li><p>Write a test that will fail or,</p></li><li><p>Refactor.</p></li></ul><p>This precludes us writing the whole program back to front, unless we write one gigantic test first, then type the code in our weird way, &amp; then the single giant test passes. That would technically be TDD, but in a really weird form.</p><p>For the original analogy to hold, we would need to get the program half-way written &amp; then not be able to move forward, either:</p><ul><li><p>We can’t write the next failing test given the code &amp; tests we already have or,</p></li><li><p>We write a failing test but we can’t get it to pass without breaking some other test.</p></li></ul><p>Using the hill climbing analogy, we have 4 options in such a stuck spot:</p><ul><li><p>Just have 2 broken tests for a while (or more than 2). This is uncomfortable but hardly fatal. It’s still TDD-ish. We’ve gone further down hill than usual but that doesn’t mean we can’t climb back.</p></li><li><p>Move the code &amp; tests to an earlier state &amp; tackle a different sequence for the tests and/or refactorings. Perhaps a different path would enable stepwise progress.</p></li><li><p>One alternative path would be to try smaller tests.</p></li><li><p>Another alternative path would be a larger next test, one that might be red for a while.</p></li></ul><p>Each of these strategies involves going downhill for a bit before resuming the climb. That’s okay. Nobody said anything about monotonically increasing. </p><h2>Fitness</h2><p>The OP claims that TDD can’t be used to write the optimal program for many problems. I’m genuinely interested in characterizing the kinds of problems or programs that are difficult to solve or write one test case at a time. Ignoring that for the moment, though, the OP never addresses what is meant by “optimal”.</p><p>The goal of TDD (or any programming) isn’t perfection, provably optimal development. Development needs to be good enough. It’s also nice if it’s an improvement on yesterday’s development. Ignoring the “optimality” red herring, what <em>are</em> we trying to achieve?</p><p>Using the hill climbing analogy, the fitness function for code is complicated &amp; multi-dimensional. Those dimensions change as a system matures (see also 3X: Explore/Expand/Extract). Here are some:</p><ul><li><p>The set of inputs for which the program works as desired.</p></li><li><p>The defect rate.</p></li><li><p>The cost to develop initially.</p></li><li><p>The cost to extend.</p></li><li><p>The cost of delay.</p></li><li><p>The opportunity cost.</p></li><li><p>The audience that can read &amp; maintain the code.</p></li><li><p>The cost of execution.</p></li><li><p>The cost of errors.</p></li><li><p>Scalability.</p></li><li><p>Coupling with other systems.</p></li></ul><p>Which of these criteria, exactly, is unachievable with TDD &amp; why? That’s the question that fascinates me.</p><h2>Sidebar: Analogies</h2><p>Thinking effectively with analogies is an art. The OP appears to have gained a surface understanding of hill climbing, seen how to apply it to TDD, then written the referenced post.</p><p>Here’s the thing with analogies. You’d better be prepared to dig deeper than your readers. I do my homework before I present an analogy. In a case like this, I would want to make sure I understood much more about hill climbing (and TDD too) before I published.</p><p>Shallow analogies invite easy debunking. In this case the OP ignored the fitness function &amp; made the mistake of assuming “optimal” was the goal.</p><p>So why am I writing such an extensive response? Because I think the OP is onto something, even if it’s not what they think they are onto. I want to encourage careful thought.</p><h2>Question</h2><p>Why does the OP care so much that TDD is bad/wrong/invalid? And not just them, for the last 6 months I’ve been responding to critiques of TDD that struck me as shallow, emotional (in the sense of clouding thought), or both. Why the hate?</p><p>I’m not saying TDD is the best way to program. I’m saying it tends to be an effective way to address the properties listed above. I’d like to understand its prerequisites, limitations, alternatives, refinements, &amp; pedagogy better. But “it can’t possibly work because of this shallow, specious analogy” doesn’t get us any closer to understanding.</p><h2>Coda: My Hill Climbing Analogy</h2><p>The OP missed a hill climbing analogy for TDD—each test is a step uphill. The gradient is measured by “the sets of inputs for which the program operates as desired”. Each test is a click of the ratchet, representing a new set of inputs that will work as desired.</p><div class="captioned-image-container"><figure><a class="image-link image2 is-viewable-img" target="_blank" href="https://substackcdn.com/image/fetch/$s_!aPw1!,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Faf538bc3-8fd2-4bc1-b10b-c0354ebdef54_480x270.webp" data-component-name="Image2ToDOM"><div class="image2-inset"><picture><source type="image/webp" srcset="https://substackcdn.com/image/fetch/$s_!aPw1!,w_424,c_limit,f_webp,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Faf538bc3-8fd2-4bc1-b10b-c0354ebdef54_480x270.webp 424w, https://substackcdn.com/image/fetch/$s_!aPw1!,w_848,c_limit,f_webp,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Faf538bc3-8fd2-4bc1-b10b-c0354ebdef54_480x270.webp 848w, https://substackcdn.com/image/fetch/$s_!aPw1!,w_1272,c_limit,f_webp,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Faf538bc3-8fd2-4bc1-b10b-c0354ebdef54_480x270.webp 1272w, https://substackcdn.com/image/fetch/$s_!aPw1!,w_1456,c_limit,f_webp,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Faf538bc3-8fd2-4bc1-b10b-c0354ebdef54_480x270.webp 1456w" sizes="100vw"><img src="https://substack-post-media.s3.amazonaws.com/public/images/af538bc3-8fd2-4bc1-b10b-c0354ebdef54_480x270.webp" width="480" height="270" data-attrs="{&quot;src&quot;:&quot;https://substack-post-media.s3.amazonaws.com/public/images/af538bc3-8fd2-4bc1-b10b-c0354ebdef54_480x270.webp&quot;,&quot;srcNoWatermark&quot;:null,&quot;fullscreen&quot;:null,&quot;imageSize&quot;:null,&quot;height&quot;:270,&quot;width&quot;:480,&quot;resizeWidth&quot;:null,&quot;bytes&quot;:1072334,&quot;alt&quot;:null,&quot;title&quot;:null,&quot;type&quot;:&quot;image/webp&quot;,&quot;href&quot;:null,&quot;belowTheFold&quot;:true,&quot;topImage&quot;:false,&quot;internalRedirect&quot;:null,&quot;isProcessing&quot;:false,&quot;align&quot;:null,&quot;offset&quot;:false}" class="sizing-normal" alt="" srcset="https://substackcdn.com/image/fetch/$s_!aPw1!,w_424,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Faf538bc3-8fd2-4bc1-b10b-c0354ebdef54_480x270.webp 424w, https://substackcdn.com/image/fetch/$s_!aPw1!,w_848,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Faf538bc3-8fd2-4bc1-b10b-c0354ebdef54_480x270.webp 848w, https://substackcdn.com/image/fetch/$s_!aPw1!,w_1272,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Faf538bc3-8fd2-4bc1-b10b-c0354ebdef54_480x270.webp 1272w, https://substackcdn.com/image/fetch/$s_!aPw1!,w_1456,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Faf538bc3-8fd2-4bc1-b10b-c0354ebdef54_480x270.webp 1456w" sizes="100vw" loading="lazy"></picture><div class="image-link-expand"><div class="pencraft pc-display-flex pc-gap-8 pc-reset"><button tabindex="0" type="button" class="pencraft pc-reset pencraft icon-container restack-image"><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-refresh-cw"><path d="M3 12a9 9 0 0 1 9-9 9.75 9.75 0 0 1 6.74 2.74L21 8"></path><path d="M21 3v5h-5"></path><path d="M21 12a9 9 0 0 1-9 9 9.75 9.75 0 0 1-6.74-2.74L3 16"></path><path d="M8 16H3v5"></path></svg></button><button tabindex="0" type="button" class="pencraft pc-reset pencraft icon-container view-image"><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-maximize2 lucide-maximize-2"><polyline points="15 3 21 3 21 9"></polyline><polyline points="9 21 3 21 3 15"></polyline><line x1="21" x2="14" y1="3" y2="10"></line><line x1="3" x2="10" y1="21" y2="14"></line></svg></button></div></div></div></a></figure></div><p>I’ve certainly gotten stuck, in the sense that I had a set of tests that I wanted to pass, I got some of them working, &amp; then I couldn’t figure out how to get the next working without breaking some existing tests. I’ve had to back up &amp; try a different sequences of tests, or a different design, or a different implementation. This would constitute a failure of “TDD as hill climbing”.</p><p></p>