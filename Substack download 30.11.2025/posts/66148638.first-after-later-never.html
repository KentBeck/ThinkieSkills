<p>We are talking about the timing of tidying with respect to a behavioral change in the system. Tidy first, then change the behavior? Change the behavior, then tidy? Or simply note messiness (in the sense that future behavior changes are going to be harder than they need be), then come back later to tidy? Or, don't tidy at all?</p><h3>Never</h3><p>Let's start with the last one. As always, we need to examine the tradeoffs involved in not tidying at all. When should we say, "Yes, this is a giant mess, &amp; we consciously choose not to do anything about it."? The best reason is because we're never going to change the behavior of the code ever ever again.</p><div class="paywall-jump" data-component-name="PaywallToDOM"></div><p>I stated the condition like that because it's rare that code truly never needs to have its behavior changed. However, it does happen. For truly static systems, "If it ain't broke, don't fix it," reasonably applies.</p><h3>Later</h3><p>Some folks think tidying later is pure fantasy, a unicorn, an honest politician. The mythological status of tidying later is used as justification for tidying too much now, whether that is before or after. I'm here to tell you that you really <em>can</em> tidy later. You may not like the prerequisite, though.</p><p>Is there enough time to do your work? I'm not asking whether you have <em>plenty</em> of time, because of course not. I'm not asking whether there's more to do than you have time for, because of course. Ask yourself, "How would we work if we had enough time?" If the answer is wildly different than what you are actually doing, then no, there is not enough time to do your work.</p><p>I invite you to examine this assumption that there isn't enough time to do your work. I've worked with large, successful, long-lived, highly profitable businesses that still believed, in the face of all the evidence of being large, successful, long-lived, &amp; highly profitable, that there just wasn't &amp; wouldn't ever be enough time to do the work. Seems bizarre, like a bird questioning the laws of physics &amp; suddenly falling out of the sky.</p><p>What would you do if you temporarily, provisionally believed that there was enough time to do you work? You might make a list of messes to tidy later (I call this my Fun List, because I have an odd notion of "fun"). Then later, rather than jumping feverishly to the next feature to implement, you might glance at your Fun List &amp; think, "I have an hour. I don't want to start something big. Why don't I take a crack at item 4?" And then you might.</p><p>That's tidying later. It can happen. Try it. Then it <em>will</em> happen.</p><p>Tidying makes future changes to the behavior of the system easier (through mechanisms we will explore in the next section). If there is an area of the system guaranteed to change (strong word, "guaranteed"), then tidying in that general area creates value if it simplifies those future changes.</p><p>Tidying later (that is, not tied to an immediate behavior change) creates value a couple of other ways. One is by reducing the tax of messiness. You are migrating from an old API to a new API. You've changed the call sites immediately affected but you have 100 more call sites to migrate later. When you've migrated them all, you can remove the old API. However, until then, you have to mirror changes made to the new API in the old API.</p><p>Tidying all those call sites isn't pointless faffing about. Once you migrate all of them, a certain class of changes becomes cheaper. There may not be a pressing need to reduce that cost but taking the pebble out of your shoe lets you walk better.</p><p>Another reason to tidy later is as a learning tool. The code "knows" how it wants to be structured. If you're listening &amp; you move the code from its current structure toward its desired structure, you're bound to learn something. Tidying is a great way to become aware of the detailed consequences of your design. Tidying illuminates the design as it could be.</p><p>Finally, tidying later just feels good. Software development is a human process. We are humans with human needs. Sometimes I just don't have the energy to tackle a new feature but I want to work. Picking an item off the Fun List &amp; tidying it brings me joy. Don't underestimate how much better you are as a programmer when you're happy.</p><h3>After</h3><p>You need to change behavior. The code is messy. You can't see how to tidy. You change the behavior anyway (good for you--mess is no excuse). But now, huzzah!, you see how the change you made could have been easier. Do you tidy after?</p><p>It depends. Are you ever going to change the behavior in this same area again? (Likely yes, for reasons we'll into in the next section, but still apply your judgement.) If you're going to change the area again, then tidy after makes some sense.</p><p>Why not just tidy first the next time you need to change behavior in this area? It might be harder later. You may have forgotten context that makes tidying easier right now. Other changes may have interfered with the tidying you'd like to do now. If waiting to tidy at a later date substantially increases the cost of tidying, consider doing it now.</p><p>Also, how much tidying are we talking about? Say the behavior change took you an hour. Spending an hour tidying after makes sense. Spending a week tidying after?--doesn't make sense. That goes on the Fun List.</p><p>So, if:</p><ul><li><p>You're going to change the same area again. Soon.</p></li><li><p>It's cheaper to tidy now.</p></li><li><p>The cost of tidying is roughly in proportion to the cost of behavior changes.</p></li></ul><p>Then sure, tidy after.</p><h3>First</h3><p>Now here, finally, at the end of the second section, we come to an answer to the question posed by the book's title. Tidy first? And the answer is...</p><p>It depends.</p><p>I love my job sometimes. So okay, yeah, of course it depends, but what does it depend on? I need to change the behavior of this code. This code is messy. Do I tidy first?</p><ul><li><p>How much harder is the messy change? It tidying doesn't help at all, don't tidy first.</p></li><li><p>How immediate is the benefit of tidying? Let's say you're not ready to change the behavior yet. You're just reading code for comprehension. Tidying helps you comprehend faster. Sure, tidy first.</p></li><li><p>How will this tidying amortize? If you'll only ever change this code once, then consider limiting your tidying. If this tidying will pay off weekly for years, then sure.</p></li><li><p>How sure are you of your tidying? Bias away from speculation. "I can see the messiness here, right here. If it's gone then this change will be easy." But also, "Tidying this will make it easier to understand. I know because I'm confused right now."</p></li></ul><p>In general, bias towards tidying first but be wary of tidying becoming an end in itself. The tidyings in the catalog are tiny precisely so you don't have to think too hard about applying them. If you tidy &amp; it doesn't pay off, no big deal. Bias towards tidying shouldn't cost you much &amp; most of the time it will pay off.</p><h3>Summary</h3><p>Tidy never when:</p><ul><li><p>You're never changing this code again.</p></li><li><p>There's nothing to learn by improving the design.</p></li></ul><p>Tidy later when:</p><ul><li><p>You have a big batch of tidying without immediate payoff.</p></li><li><p>There's eventual payoff for completing the tidying.</p></li><li><p>You can tidy in little batches.</p></li></ul><p>Tidy after when:</p><ul><li><p>Waiting until next time to tidy first will be more expensive.</p></li><li><p>You won't feel a sense of completion if you don't tidy after.</p></li></ul><p>Tidy first when:</p><ul><li><p>It will pay off immediately, either in improved comprehension or in cheaper behavior changes.</p></li><li><p>You know what to tidy &amp; how.</p></li></ul>