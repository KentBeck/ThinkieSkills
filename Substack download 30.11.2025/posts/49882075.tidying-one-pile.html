<p>[Here is the last tidying in the catalog. Next youâ€™ll see chapters on managing the process of tidying to trade off positive &amp; negative impact.]</p><p>Sometimes you read code that's been split into many tiny pieces but split in a way that hinders you from understanding it. Inline as much of the code you need until it's all in one big pile. Tidy from there.</p><p></p><div class="paywall-jump" data-component-name="PaywallToDOM"></div><p>We'll talk about the roots of this situation in more detail when we discuss Lumpers and Splitters. For now, suffice to say that the purpose of code is overwhelmingly to be read &amp; understood so it can be changed. Tidy First? has a bias towards lots of little pieces, both theoretically, to increase cohesion as a path to reducing coupling, and practically, to reduce the amount of detail that needs to be held in your head at any one time. Sometimes, though, this process goes wrong.</p><p>Some symptoms you're looking for are:</p><ul><li><p>Long, repeated argument lists.</p></li><li><p>Repeated code, especially repeated conditionals.</p></li><li><p>Poor naming of helper routines.</p></li><li><p>Shared mutable data structures.</p></li></ul><p>Given the bias towards more, smaller pieces, creating One Pile feels odd while tidying. However, it's strangely satisfying. I've been trying to understand the code in pieces. I'm starting to doubt my own abilities. I turn 180 degrees and start lumping it all together (it really helps to have automated refactorings for this, but I'll do it manually if I have to). What a relief!</p><p>As the pile gets bigger, the shape starts to emerge in my mind. I see--first we calculate this, then we use it to calculate that! Why didn't they just say so? Now I get to ask the title question--should I tidy first? Or just make the change I can now see?</p>