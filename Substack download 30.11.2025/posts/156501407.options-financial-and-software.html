<blockquote><p>Dang it’s been a minute. I’ve been stuck writing because there are a bunch of refactoring chapters I’m just not excited to write. I need to get some momentum going. Since so many folks found the “software as options” metaphor in TF? helpful, I decided I should follow up with the next level of exposing the metaphor.</p></blockquote><p>In <em>Tidy First?</em> we saw the economic value of a software system as the sum of:</p><ul><li><p>The net present value of the system's cash flows. (That is, the timing of expenses &amp; revenue are important as well as their magnitude--especially with higher interest rates.)</p></li><li><p>The options value of the software--all the things we <em>could</em> do to improve net present value in the future.</p></li></ul><p>Imagine we are choosing between buying 2 businesses. The first generates $2000/month in revenue &amp; costs $1000 to run. The second has the same net present value--$2000/month in, $1000/month out. The first, though, is a mess. We can't change anything, can't implement any new features. The second is ready for a wide variety of new features. Which would we pay more for?</p><p>That difference in price is the options value of the software. We enhance that options value when we design the software, when we make elements more cohesive, when we reduce coupling.</p><h2>Calls</h2><p>This metaphor of "options" is close to being literally true, but there are similarities &amp; differences with options as they are traded on financial markets &amp; the "real" options we deal with in software. This chapter digs into how software options &amp; financial options resemble &amp; differ from each other.</p><p>A financial option is a promise--"You can buy 1 egg for $1 dollar any time before Friday". It's less squishy than an actual egg, especially if we put it in our pocket, but it conveys many of the same benefits of an egg. If we want an egg before Friday, we can have one, and at a known price.</p><p>This variety of option (a "call" because it lets us call for an egg) is defined by 4 parameters:</p><ul><li><p>Underlying--an egg.</p></li><li><p>Strike price--$1.</p></li><li><p>Duration--before Friday.</p></li><li><p>Premium--what we had to pay to get someone to make us this promise.</p></li></ul><p>In the financial world you don't typically take possession of the underlying asset. You don't exercise the option &amp; receive an egg. When you exercise the option, the difference between the price of the egg at that moment &amp; the strike price of the option is credited to your account.</p><p>I can recommend going deep into the options rabbit hole. It's a fascinating mechanism with astonishing implications. I'm going to avoid that here for the sake of brevity.</p><p>The key advantage financially of the promise compared to just buying the egg outright is that if the price of the egg goes up, we gain money on the egg in our pocket (assuming it is still intact). If the price of the egg goes down, the egg in our pocket loses value while the premium we paid for the promise is all we can ever lose.</p><p>It's this can-win-can't-lose that we will take advantage of in software development.</p><h2>Software Options</h2><p>Options in software look similar-but-different. "We can implement that report in 2 weeks" is an option. Here are the similarities, then we'll look at the differences.</p><ul><li><p>Underlying--the report.</p></li><li><p>Strike price--2 weeks of the team's time.</p></li><li><p>Duration--we could implement it in the next 2 weeks, or 2 weeks starting June 1.</p></li><li><p>Premium--everything we've invested so far to have a system we can change--tests, tooling, a gelled team, tidy design.</p></li></ul><p>Running a software project looked at as options involves choosing which option to exercise next, which one potential to turn into reality next &amp; which to leave for the future. Simultaneously, the team works (e.g. by tidying) to maintain the ability to exercise options in the future.</p><p>This one-at-a-time exercise is the first difference between financial options &amp; software options. If I have 10 financial options, I can exercise all of them at the same time. There's no limit. In software options, the team can only exercise as fast as they can exercise. I may have 10 features I'd like to implement next, but I'm going to get them at a rhythm.</p><p>Think of a small company stumbling over a huge opportunity. They hire as quickly as they can so they exercise as many of their options as possible. At the same time, some of the new folks are there making sure that the <em>rest</em> of the folks can keep exercising options.</p><h3>Underlying</h3><p>In software options, the underlying asset is a behavior change, a feature. Like financial assets, we expect this feature to increase revenue, decrease costs, or both. However, unlike a financial asset, there is no known value for the feature. We may know that we want a report, but how much is it worth to us? Given the one-at-a-time exercise, how much are we costing ourselves by delaying everything else?</p><p>There's not a value we can assign to a feature, except as a form of self-soothing. The exception is enterprise sales, where "implement OAuth" might be the key to making a sale. Still, we don't know how much that feature will be worth in the future.</p><p>The goal of this chapter is to help you develop an intuition, to develop judgement, not to create a perfectly correct numerical value. The good news about software is that it doesn't have to be perfectly predictable to be valuable. We work in fields of gold.</p><p>Another difference in the underlying assets between software options &amp; financial options is that financial options are a promise for a fixed quantity. Software options are subject to slicing. You can't buy half an egg but you can implement a simpler form of a report, one that if you are crafty provides most of the value of the fancy report.</p><p>Because financial options always get resolved to a currency, you don't have to worry about the combined effects of multiple options. We can have a call on an egg, a call on a bond, &amp; a call on lumber &amp; when the dust settles we have money. Software options combine unpredictably. A feature can lay dormont until its value is revealed by another feature years later. And sinisterly, a feature can work fine until a later feature destroys its value.</p><p>Our stream-of-software-options becomes a blessing when we include cross-talk between features. You might <em>think</em> you'd like to implement everything at once, but the chaos wouldn't be worth it.</p><h3>Strike Price</h3><p>In financial options the strike price is just a number--$1. In software options our "strike price" is always going to be an estimate &amp; estimates are always (for some large but not infinite value of "always") going to be wrong.</p><p>Turns out this is okay. We don't know the value of the underlying asset, the feature, either. But we don't have to. We can develop profitably without numbers.</p><p>The larger the software "strike price", the greater the chance that it will blow up to 10 or 100 times the original estimate. You hate to get $1 billion dollars into a project only to realize that the value of what you've built is $0. That's why we slice features, whether at the scale of hours, days, weeks, months, or years.</p><p>If the promise said, "$1 for 1 egg by Friday. Or maybe $10. Just maybe $100. And you won't know until you've spent most of the money." we'd never pay for that promise. We'd rather just get the egg in our pocket today &amp; take the chance of the price of eggs falling.</p><p>Strike prices for software options vary in ways we can control, unlike the fixed strike price of financial options. Tidying reduces the strike price of all future options involving the tidied code.</p><p>Strike prices can also rise. We don't even have to be doing a bad job at one feature to make it more difficult to implement another feature in the future.</p><h3>Duration</h3><p>It's tempting to view duration in software options as infinite. We could implement the report today or next year, who cares? In a sense it's true that we don't have a ticking clock on features, after which they can never be implemented. But we don't really know up-front that sell-by date. "Jesse left &amp; nobody else knows how to change that code." A bunch of options just turned to smoke.</p><p>But also, "I dug into that code &amp; now I know what I can change &amp; what I can't." Exploration has created options where none existed before.</p><p>Duration, like strike price, is, to a degree, under our control. Investing in structure, tests, tooling, &amp; team stability all extend the duration of our software options.</p><h3>Premium</h3><p>You can go to a market to see that the right to buy 100 shares of Nvidia for $120 per share by June 20, 2025 will cost me $16.60 per share right this moment. What is the premium we pay for software options? It's not so clear.</p><p>Everything we have invested in the software to date is the premium we have paid so we can exercise the next option. Some of those investments have made the next feature easier to implement (lowered its strike price). Others of those investments have made the next feature more expensive to implement.</p><p>With software options we can't easily assign a premium to <em>this</em> option. But, again, that's okay. That money's all spent anyway.</p><h3>Value</h3><p>The above is a set-up for the fundamental insight in software development. I first learned about options in the 70s as a kid reading the Wall Street Journal. I returned to options when I had to implement options pricing formulas in the 90s. When I tied options to software development it completely scrambled my understanding of software value. I can't hope to give you exactly that experience, but I'll do my best,</p><p>What makes a financial option become more valuable?</p><ul><li><p>Higher underlying price. As the price of the egg rises, the right to buy it becomes more valuable.</p></li><li><p>Lower strike price. Of two otherwise-identical options, the one with a lower strike price is more valuable.</p></li><li><p>Longer duration. The longer duration of the two options is more valuable.</p></li><li><p>Lower premium. The cheaper promise is worth more, all else equal.</p></li></ul><p>Applying this to software options:</p><ul><li><p>More valuable features. The more valuable the features, the better their net present value, the more valuable the option.</p></li><li><p>Cheaper development. If we can reduce the cost of a feature, the right to build that feature becomes more valuable.</p></li><li><p>Longer duration. Simply extending the lifetime during which software can be changed creates value.</p></li><li><p>Lower premium. Nothing we can do about sunk costs in software except not get attached to them.</p></li></ul><p>None of that was the blinding insight, though. The deepest source of value in software options was still hiding from me.</p><p>I was taught in school that development should be predictable. We'll write the perfect specification &amp; everything else will go smoothly. And then it didn't, so we'd write a better specification next time. And it went worse.</p><p>Then I did all this work with options &amp; I learned the single biggest source of value in options is volatility. The value of an option as opposed to the underlying is most sensitive to the volatility in the value of the underlying. The less we know about the future value of a feature, the greater the value of holding an option for implementing it.</p><p>Ka. Boom. I had been trying to make development perfectly predictable. The less predictable the situation, the less valuable my development.</p><p>Focusing on options turned my head around. I'm excited when I don't know which feature is going to provide value. The better I got at creating &amp; maintaining options &amp; the <em>less</em> I could predict the future, the more valuable my development. Volatility was my friend, my bank account, not my enemy! Halleluah and amen.</p><p>In the next chapter we'll stay with options &amp; explain, with options thinking, why slicing is so valuable.</p>