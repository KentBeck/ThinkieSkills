<blockquote><p>I’ve had some complaints about the pace of the publishing, that there’s too much to read. I can space my posts out a little, but when I’m in full writing mode as I am now, you’re going to see draft chapters in pretty much real time. If you’re behind, you’ll get caught up. The community is providing excellent, timely feedback, which is what I need.</p></blockquote><p>What do we mean when we say a design is "good"? Good for whom? Good for what purpose(s)?</p><p>After all, you're reading the second book in a series intending to help you improve your designs, and we haven't even talked about what we mean by "improve", except tangentially.</p><h2><strong>"Good"</strong></h2><p>A design is good if it supports implementing the next feature with a minimum of extra effort. Each feature carries intrinsic complexity. You're just going to have to write a certain number of if's &amp; while's before the feature will pass its tests (or polymorphic messages in object languages).</p><p>Each design also imposes accidental complexity on each feature, the set of all the other changes you need to make before the feature can be deployed. Design improvement reduces the cost of this extrinsic complexity.</p><h2><strong>Cost</strong></h2><p>We can't just evaluate the fitness of a design at a point in time. We care about the cost of the behavior changes plus the cost of structure changes into the future. "Our primary objective is 'minimum-cost' systems," say Yourdon &amp; Constantine, the patron saints of software design. They mean the cost over time.</p><h2><strong>Value</strong></h2><p>In <em>_Tidy First?_</em> we extended the objective of system development to optimizing value, but value is tricky. Value isn't just revenue - cost.</p><p>Costs are complicated—</p><ul><li><p>The cost of operating the system.</p></li><li><p>The cost of future behavior changes (features).</p></li><li><p>The cost of future structure changes.</p></li><li><p>Discounting all these costs to the present day (net present value).</p></li><li><p>Evaluating all of the above in a fog of uncertainty about what future features we will want &amp; what we will learn about improving the structure.</p></li></ul><p>Revenue is also complicated—</p><ul><li><p>The (unknown) effect of (unknown) future features on revenue.</p></li><li><p>Again discounted because of net present value.</p></li><li><p>In a foggy competitive marketplace.</p></li></ul><p>Optionality adds value to systems. Given 2 systems with equivalent cash flows, we'd pay more for the system that had more options for future change than for the one with fewer. Empirical software design increases optionality, creating value even before we see dollars in accounts.</p><p>The final element of value is survival. All those future cashflows make no difference if the system doesn't survive long enough to realize them. A key evolution in my thinking since writing <em>_Tidy First?_</em> is a deeper understanding of the importance of survival. The chapter on Survival goes deeper into this element of the economics of software &amp; how software design influences system mortality.</p><h2><strong>People</strong></h2><p>Good for whom? The dollars, after all, are there to serve the people, not the people to serve the dollars. If software design is an exercise in human relationships, which humans are we talking about?</p><p>In <em>_Tidy Together?_</em> we are primarily interested in relationships between people who are changing the system. But even these folks are no monolith--</p><ul><li><p>Experienced developers focused on future features.</p></li><li><p>Experienced developers focused on structure. (Used to be called "architects".)</p></li><li><p>Newer developers learning their craft, both features, structure, &amp; social obligations.</p></li><li><p>"Visiting" developers who need changes to the system without necessarily sticking around to live with the consequences of their changes.</p></li></ul><p>The same design can be good for some of these constituencies &amp; bad for others. Choosing the audience &amp; adapting to their skills, worldview, &amp; incentives is also part of design.</p><h2><strong>Heuristics: The Four Rules</strong></h2><p>Given all the complexity &amp; uncertainty of evaluating a design, how can you decide whether one proposed design is better or worse than another? In <em>_Extreme Programming_</em>, one of the practices was "Simple Design". By "simple", I meant at the time that we didn't add design elements on speculation. I now wish I'd used a different word, as you're about to see.</p><p>Someone asked, "But what do you mean by 'simple'?" I wrote the following in Ward's Wiki (https://wiki.c2.com/?XpSimplicityRules) in response:</p><p>A design for a system is "simple" in the degree it follows this prioritized list of rules:</p><ol><li><p>The Working Rule. The system works. If a new design state breaks the system, it's bad. Bad is not simple. Bad is complicated. (It astonishes me how many designers neglect this.)</p></li><li><p>The Communication Rule. The system expresses all the concepts of interest to readers. Change a design so it's easier to understand, you've made it simpler. (See, "simple" isn't the right word.)</p></li><li><p>The Duplication Rule. The system contains no duplication. (I'd soften this today--duplication is coupling but sometimes eliminating it costs more than carrying it along for the moment.)</p></li><li><p>The Backpack Rule. Given the above properties, the system contains the fewest possible elements &amp; relationships.</p></li></ol><p>Evaluate proposed structure changes with the above rules &amp; you'll tend to end up with changes that increase the value of the system in spite of all the uncertainties about the future.</p><p>It's not enough to rely solely on these rules. Don't justify straining relationships with your fellow changes by reference to these rules. "I was just eliminating duplication." "Yeah, but now I can't read my code." Design fail.</p><h2><strong>Summary</strong></h2><p>We have a system. We want to change its behavior. That change seems harder than necessary. Here's an optional structure change. Is it good? </p><p>Should we tidy together before we implement the behavior change? We'll talk more about this decision in the next chapter on timing.</p>