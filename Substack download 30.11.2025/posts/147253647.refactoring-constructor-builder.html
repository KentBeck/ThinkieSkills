<p>Representing the creation of objects offers challenging tradeoffs. Readers looking at the code of a particular creation need to understand what is intended by that creation. What object are they getting back &amp; what is that object prepared to do for them? Readers who want to create an object themselves, whether they are copying from an existing creation or reading the construction code itself, need to understand what parameters are mandatory, what parameters (if any) are optional, &amp; what purposes are served by the various construction options.</p><h3>Pattern</h3><p>You see long lists of parameters to construction (whether represented as a constructor or a factory method) with many variations.</p><h3>Forward</h3><ol><li><p>Create a FooBuilder. The method to create the FooBuilder takes all the mandatory parameters.</p></li><li><p>For each optional parameter, create a method on FooBuilder for setting that parameter. Each of these methods returns the builder.</p></li><li><p>Finish by adding an <code>object()</code> method that returns the built object.</p></li><li><p>The implementation is up to you. You can store the parameters, perhaps in a map, &amp; create the object lazily. You can create the object eagerly &amp; set values on it as you go.</p></li></ol><h3>Example</h3><p>Suppose we have a Pen object that has a mandatory diameter &amp; color, but optional opacity &amp; texture. We could have:</p><pre><code>Pen(diameter, color)
Pen(diameter, color, opacity)
Pen(diameter, color, texture)
Pen(diameter, color, opacity, texture)</code></pre><p>(Languages with optional parameters solve this problem of combinations of optional parameters differently.)</p><p>Replace this interface with a builder:</p><pre><code>PenBuilder(diameter, color)
PenBulder.opacity()
PenBuilder.texture()
PenBuilder.object()</code></pre><p>Now invocations look like this:</p><pre><code>pen = PenBuilder(diameter, color).
  texture(texture).
  opacity(0.75).
  object()</code></pre><h3>Discussion</h3><p>The first question to ask when considering creating a builder-based interface for object creation is, "Is this object too big?" When you already have 10 parameters, adding the 11th just doesn’t seem like that big a deal. Maybe, though, a better, more cohesive, design would be to split the object. Alternatively, perhaps a Parameters Object plus a bunch of Move Logic To Data would produce a more cohesive parent object.</p><p>As mentioned in the example, languages with optional parameters offer a different way to represent the same situation—​some mandatory parameters &amp; some optional parameters.</p><pre><code>Pen(diameter, color, opacity = 1.0, texture = Texture.smooth())</code></pre><p>If you’re in one of those languages, use the idiomatic expression. That’s what informed readers will be expecting.</p><p>I’ve seen this refactoring applied even for mandatory parameters. Don’t. I think it’s done out of a misguided sense of symmetry—​treat all parameters the same. Except all parameters aren’t the same. Some subset needs to be there to have a well-formed object. Tell a reader clearly which those are.</p><p>Another alternative to the builder-based interface is to have a map as a last construction parameter, typically labelled "options". Again, don’t. Readers want to know what the optional parameters are. The builder-based interface is a clear place for readers to go to find out. A map can have anything (or nothing) as keys.</p><h3>Coupling &amp; Cohesion</h3><p>A purely constructor-based or factory-method-based construction interface creates coupling between all the invocations &amp; the declaration. Add a parameter &amp; you risk having to change all the invocations. The builder-based construction interface leaves invocations immune to change. New invocations can use the new parameter if desired. Old invocations remain unchanged.</p><h3>Inverse</h3><p>If you have a builder-based interface that has evolved to have no optional parameters, inline it. The extra level of indirection of the builder is no longer buying you anything. Convert to a constructor or factory method.</p><h3>Subsequent refactorings</h3><p>Look for Parameters Objects to simplify construction.</p>