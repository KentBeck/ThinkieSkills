<p>Software creates value 2 ways:</p><ul><li><p>What it does today</p></li><li><p>What all new things we can make it do tomorrow</p></li></ul><p>"What it does today" is the system's behavior--calculating payroll, sending dropship orders, notifying friends. (And yes, all software systems are socio-technical systems &amp; we won't be designing the socio- part of it just yet.)</p><p>Behavior can be characterized various ways:* Input/output pairs--this many hours at this pay rate in this jurisdiction should result in a paycheck like this &amp; a tax filing like that.* Invariants--the sum of all entitlements should equal the sum of all deductions.<br>Behavior creates value. Rather than have to calculate a bunch of numbers by hand, the computer can calculate millions of them every second. Turns out people will pay not to have to calculate numbers by hand. If running the software costs $1 in electricity &amp; you can charge folks $10 to run it on their behalf, then you have a business.</p><p>In theory, this business could run forever producing $10 out for every dollar we put in. We know this is an over-simplification. Bit rot is real. Something is always changing. Staying in place in the river requires constant paddling. But for purposes of the distinction I'm drawing, this is good enough for the moment.</p><p>You know what's better than a machine that spits out $10 for every $1 you put in? </p><div class="paywall-jump" data-component-name="PaywallToDOM"></div><p>A machine that spits out $100 for every $10 you put in. Or $20 for every $1. How are we going to get to that better machine?</p><p>In a word, optionality. The mere presence of a system behaving a certain way changes the desire for how the system should behave (Heisenberg's Requirements Uncertainty Principle). However much you'd pay for the $10/$1 machine, you'd pay more for one that could turn into either a $100/$10 machine or a $20/$1 machine--EVEN IF YOU DIDN'T KNOW WHICH IT <em>_WOULD_</em> TURN INTO.</p><p>This is the secret it took me decades to absorb. I didn't have to change the behavior of my system to make it more valuable. As soon as I added to the options for what it <em>_could_</em> do next, I had already made money. (I went down the rabbit hole of options pricing formulas to really cement this understanding, but I trust you to figure out how to convince yourself.)</p><p>Options are the economic magic of software, especially the option to expand. If you can build 1,000 cars there's no guarantee you can build 100,000. If you can send 1,000 notification, you almost certainly can, with work, send 100,000 (when we get to the outer limits of technology expansion becomes less certain, but in early growth expansion isn't risky).</p><p>One of the coolest thing about options is that the more volatile the environment, the more valuable options become. This is part of the motivation to subtitle Extreme Programming "Embrace Change". As a young engineer I was terrified when a seemingly settled situation turned chaotic. As I learned to enhance optionality I saw chaos as an opportunity.</p><p>What interferes with options? Here are some scenarios that reduce the options value embedded in your software:</p><ul><li><p>A key employee quits. Now changes that would have taken days take months.</p></li><li><p>You distance yourself from your customers. If you get a provocative suggestion a month instead of one every day, you have fewer options.</p></li><li><p>The cost of changes skyrockets. Instead of being able to exercise an option a day you can only exercise an option a month. Fewer options, less value.</p></li></ul><p>Nothing in the scope of this book directly addresses the first 2 of these options killers, but we can react to the third. We can keep the kitchen clean as we cook.</p><p>The structure of the system doesn't matter to its behavior. One big function, a whole bunch of itty bitties, same paycheck comes out. The structure creates options. The structure could make it easy to add new countries to our paycheck calculation or it could make it hard. </p><p>Here's the problem--structure is not legible in the same way behavior is legible. There's a reason product roadmaps are lists of features (behavior changes). It's easy to see when the behavior changes--a button appears that wasn't there before. <br>Even though we know that we have to invest in structure to maintain &amp; expand optionality, we can't really tell if we have. The code is easier to change? Really? We can't really tell if we've done enough. If you invested more in the structure the code would be even easier to change? Really? We can't really tell if we've made the right investments in structure. The structure changes were the best way to make the code easier to change? Really?</p><p>And so people get muddled about structure changes in ways they don't about behavior changes. This book is not here to answer those questions for you, it's here to help you answer those questions for yourself. Start by understanding that structure changes &amp; behavior changes are both ways to create value, but that they are fundamentally different. How? In a word, reversibility.</p>