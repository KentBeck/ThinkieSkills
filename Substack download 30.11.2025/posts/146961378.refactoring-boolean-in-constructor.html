<blockquote><p>I’m not sure this will make the cut in the book. It seems a bit niche. However, I’m basically writing every OO design trick I know. Let me know. Also, this is quite object-oriented specific. I’ve tried to make most things functional/object agnostic. Finally, if you have a good example I’d love to see it. Examples are the hardest part.</p></blockquote><p>You won’t see many refactorings here that bias towards creating class hierarchies. Complicated class hierarchies are petri dishes of coupling. However, there are responsible ways to use subclassing.</p><h3>Pattern</h3><p>You see a boolean passed to a constructor. The boolean is assigned to an immutable field. That field is used frequently in methods of the object.</p><h3>Forward</h3><ol><li><p>Apply Constructor &lt;→ Factory Method so callers are decoupled from the concrete class being returned.</p></li><li><p>Create 2 subclasses of the class, one for true &amp; one for false. Name them appropriately.</p></li><li><p>In the factory method, return an instance of the appropriate subclass.</p></li><li><p>Extract helper methods for all the conditionals using the boolean.</p></li><li><p>Push down those helper methods to both subclasses.</p></li><li><p>Simplify the conditionals to either the consequent or alternative.</p></li></ol><h3>Example</h3><p>Oh dear…​ TODO</p><h3>Discussion</h3><p>Complexity creeps up on you. We rarely set out to write code that’s hard to read. Some code gets a little janky. The next time we modify it we don’t have time or don’t see how to simplify it, so it gets jankier.</p><p>Conditionals are like that. Maybe we pass a boolean to one function, use it in a conditional. Then to another function in the same class. Realize we can apply Repeated Parameter &lt;→ Constructor Parameter. Add another half dozen conditionals. Now we’re in the soup.</p><h3>Coupling &amp; Cohesion</h3><p>Repeated conditionals are a subtle form of coupling. Finding one place for the conditional to live removes that coupling—​if you ever have to change it you only change it in one place.</p><p>This refactoring only applies to a single conditional, but the same pattern applies to enums, explicit or implicit. If you have "here are the four cases" scattered around the code, especially if they expressed differently each time (explicit switch statement, nested conditions, sometimes an implicit default), then finding them all, much less changing them all correctly, becomes challenging. (This is where Constantine’s Equivalence kicks in.)</p><h3>Inverse</h3><p>Seems rare, but if we see that both subclasses have gotten slimmer &amp; slimmer &amp; now have no logic left (or the logic has become identical), then :</p><ol><li><p>Push up the identical methods until the subclasses are empty.</p></li><li><p>Replace the subclasses with the superclass in the factory method.</p></li><li><p>Eliminate the boolean as a parameter, since it is no longer used.</p></li><li><p>Consider applying the inverse of Constructor &lt;→ Factory Method. (I do this less often, since I like the flexibility of the factory method.)</p></li></ol><h3>Subsequent refactorings</h3><p>You may be able to further simplify the code in the classes you just created or their superclass.</p>