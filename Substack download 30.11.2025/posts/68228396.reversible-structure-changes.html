<p>What's the difference between a bad haircut &amp; a bad tattoo? The bad haircut grows out but the bad tattoo is forever (well, not forever forever, but way harder to undo).</p><p>How are structure changes different from behavior changes? One property, relevant to "Tidy First?" is that structure changes are generally reversible. You extract a helper function &amp; you don't like it? Inline it. It's like that helper never existed.</p><p>Constrast this with a regrettable behavior change. Send out 100,000 tax notices with the wrong number on them. Now what? Well, it'll cost you plenty to fix them. The damage to your reputation may be permanent. If only you'd caught that problem 5 minutes <em>_before_</em> you sent the notices instead of 5 minutes <em>_after_</em>.</p><div class="paywall-jump" data-component-name="PaywallToDOM"></div><p>In general, we should treat reversible decisions differently than irreversible decisions. There's great value in reviewing, double-, triple-checking irreversible decisions. The pace should be slow &amp; deliberate. Even if there is great upside to the decision, there is also great downside if we get it wrong. Yes we want the upside but even more we want to avoid the downside.</p><p>How about reversible decisions? Most software design decisions are easily reversible. There is some upside to making them (making behavior changes easier, as we've seen throughout this book). But there's really not much downside, because we can so easily reverse the decision if it turns out to be wrong.</p><p>Because there is so little value to avoiding mistakes, we shouldn't invest much in avoiding mistakes. That's the economic reality I was hinting at when choosing "tidying" to describe what we're doing in this book. It's no big deal. Just a tidying.</p><p>Code review processes (which I've promised multiple times to trash, but now is not the time) don't distinguish between reversible &amp; irreversible changes. We end up making the same investment with radically different payoff profiles. What a waste.</p><p>What about? What about design changes that <em>_aren't_</em> reversible? For example, "Extract As A Service" tends to be a big deal &amp; hard to undo. First, think about it some more, for example by actually implementing a prototype first. And by "implementing" I mean putting it into production. Does this require a feature flag? Okay. Does it require checking the feature flag in a whole bunch of places? Okay, tidy first so it only requires a few feature flag checks.</p><p>Do you see what we're doing? We are making "Extract As A Service" reversible, at least for a while. If we get half way into it and realize this is one of those services that really could have been a SQL query (thanks, Josh Wills), then we can change it without too much fuss.</p><p>Another scenario where reversible design decisions become irreversible is when the decision propagates throughout the code base. Now changing from an integer to a long would require changing a millions spots, some of them extremely tricky. Okay, 1) think a little more about whether this decision is one that is likely to propagate &amp; 2) yeah that happens and when it happens we get out of it one tidying at a time. Tidy first or after for a while, then tidy later to finish reversing the decision. (As always in short, interruptible slices.)</p><p>There seems to be an idealistic form of geek thinking that believes if only we made decisions better we would never make mistakes. I was a young adherent, a worshipper at the altar of "If Only I Was Infinitely Smart". Fortunately, I got over it. I learned the value of reversibility (long before I had a name for it) &amp; realized the value of making decisions reversible.</p>