<p>Pattern: You are creating something that will end up with many elements &amp; you are stuck on where to start.</p><p>Transformation: Start with one tiny element. Grow it. When it gets uncomfortably large, split it along the revealed natural fault lines.</p><p>The “natural” tendency is to say, “We know we’re going to split X from Y, so let’s do it now.” We’ll have a front-end &amp; a back-end. We’ll put tests in this directory &amp; code in that directory. We’ll have a team for each of the applications &amp; a team for shared infrastructure.</p><p>Those outcomes are fine. It’s the timing that this Thinkie addresses. While the system is small, the cost of lumping a little too much stuff together is small.</p><p>Be patient. You may “know” that the system will be divided in X &amp; Y. If you divide it now, the boundary will only be as good as your preconceptions. You will have a harder time incorporating anything you learn.</p><p>“But I’ve done this 5 times &amp; I <em>really, truly know</em> that the system will divide up this way”—all the more reason to grow <em>then</em> split. Maybe this time you’ll discover an <em>even better</em> way to split. You can always split it the way you guessed you would split it.</p><h2>Example</h2><p>Say I’m going to write a complicated algorithm. Grow <em>Then</em> Split suggests starting the whole algorithm inside the test case. Start with the assertion [ed: remember to write the Thinkie Work Backwards].</p><p><code>testBasics<br>  assertEquals(actual, expected)</code></p><p>Now the first few lines of the algorithm:</p><p><code>testBasics<br>  actual = …maybe the base case of the algorithm…<br>  assertEquals(actual, expected)</code></p><p>Then extend the algorithm, maybe by writing the next few lines. If you’d need a new test case, Grow <em>Then</em> Split suggests a tidy first move—extract those lines as a function, but extract them locally to the test class. Yes, eventually there will be a complex interface to the algorithm, tens of classes of implementation, thousands of lines of code. For now this organization is good enough.</p><p><code>testBasics<br>  actual = algorithm()<br>  assertEquals(actual, expected)</code></p><p><code>algorithm(parameters)<br>  return …maybe the base case of the algorithm…</code></p><p><code>testOne<br>  actual = algorithm(new parameters)<br>  assertEquals(actual, expected)</code></p><h2>Conclusion</h2><p>My good friend Jessica Kerr pointed out that Grow <em>Then</em> Split emphasizes the connections between elements first, then the elements second. Because the complexity is most often embedded in the connections, &amp; because I don’t handle glops of complexity well, GTS works well for me. I use it for organization structure, directory structure, code structure—pretty much every time I know I’m going to end up with related elements.</p>